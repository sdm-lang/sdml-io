#+TITLE: SDML Meta-Model in UML
#+AUTHOR: Simon Johnston
#+EMAIL: johnstonskj@gmail.com
#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../rtd-sdml.css"/>
#+LATEX_HEADER: \usepackage{makeidx}
#+LATEX_HEADER: \makeindex
#+OPTIONS: toc:3 ^:{}

#+BEGIN_SRC emacs-lisp :exports none
(require 'ob-plantuml) ;; builtin
(setq org-confirm-babel-evaluate nil)
#+END_SRC

#+BEGIN_ABSTRACT
This document is a non-normative addition to the documentation for The Simple Domain Modeling Language (SDML) and
describes a UML meta-model for the SDML language.
#+END_ABSTRACT

* Introduction
:PROPERTIES:
:CUSTOM_ID: mmodel:introduction
:END:

While the normative description of SDML exists in the main documentation at [[https://sdml.io]] as an EBNF grammar and
RDF/OWL Ontology. However, for tool makers, an object model is often more easily consumed and useful for /tool-to-tool/
integration. The presentation form uses UML (specifically the PlantUML tool) as it is a standard and only commonly used
elements are used here.

The model is organized into a set of separate packages and these are shown, with their dependencies in figure
[[fig:metamodel-overview]].

#+NAME: src:metamodel-overview
#+BEGIN_SRC plantuml :file ./metamodel-overview.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50

package Foundation {}

package Modules {}
Modules ..> Foundation: <<import>>

package Annotations {}
Annotations ..> Foundation: <<import>>
Annotations ..> Values: <<import>>

package Constraints {
    package Environments {
    }
    package Sentences {
    }
    package Terms {
    }
    Environments ..> Foundation: <<import>>
    Environments ..> Values: <<import>>
    Environments ..> Sentences: <<import>>
    Sentences ..> Foundation: <<import>>
    Sentences ..> Terms: <<import>>
    Terms ..> Foundation: <<import>>
    Terms ..> Values: <<import>>
}
Constraints ..> Annotations: <<import>>
Constraints ..> Datatypes: <<import>>

package Datatypes {}
Datatypes ..> Foundation: <<import>>
Datatypes ..> Values: <<import>>

package SequenceTypes {}
SequenceTypes ..> Foundation: <<import>>
SequenceTypes ..> Modules: <<import>>
SequenceTypes ..> Values: <<import>>

package ProductTypes {}
ProductTypes ..> Foundation: <<import>>
ProductTypes ..> Modules: <<import>>

package SumTypes {}
SumTypes ..> Foundation: <<import>>
SumTypes ..> Modules: <<import>>
SumTypes ..> Values: <<import>>

package Values {}
Values ..> Foundation: <<import>>
Values ..> Datatypes: <<import>>
Values ..> SequenceTypes: <<import>>
Values ..> SumTypes: <<import>>

@enduml
#+END_SRC

#+NAME: fig:metamodel-overview
#+CAPTION: Overview of Metamodel Packages
#+RESULTS: src:metamodel-overview
[[file:./metamodel-overview.svg]]

* Package Foundation
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation
:END:

This package contains the basic semantic components from which the rest of the language is built. Certain classes here
are /paired/, so ~Type~ and ~Typed~, ~Name~ and ~Named~, and ~Named~ and ~Namespace~. 

#+NAME: src:metamodel-foundation
#+BEGIN_SRC plantuml :file ./metamodel-foundation.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    abstract class "Namespace<T extends Named>" as g_Namespace {
        +members: {unique} 0..* T
    }
    abstract class Named {}
    class Name {}
    
    g_Namespace ..> Named
    Named *---right---> "identity\r1" Name

    abstract class Definition {}
    Definition -up-|> Named
    Definition ---> "parent\r0..1" Definition

    abstract class Type {}
    abstract class Typed {}

    Type -up-|> Named
    Typed "members\r0..*" -up-> "type\l1..*" Type
}
@enduml
#+END_SRC

#+NAME: fig:metamodel-foundation
#+CAPTION: The Foundation Package
#+RESULTS: src:metamodel-foundation
[[file:./metamodel-foundation.svg]]

** Abstract Class Definition
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation-definition
:END:

Some element in the model that acts as a definition, i.e. a classifier.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
- ⏶ /=Annotated=/
  - ∘ /=Definition=/
    - ⏷ /=ModuleDefinition=/
#+END_HIERARCHY
    
** Class Name
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation-name
:END:

The name of something in the model, names must be unique within any enclosing namespace.

Syntax: ="/\p{Lu}\p{Ll}][\p{Lu}\p{Ll}\p{Nd}]*(_[\p{Lu}\p{Ll}\p{Nd}]+)*/"=

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ =String=
  - ∘ =Name=
#+END_HIERARCHY

** Abstract Class Named
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation-named
:END:

A base class for named model elements, often members of a namespace.

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Named=/
  - ⏷ /=Definition=/
  - ⏷ /=Type=/
#+END_HIERARCHY

#+CAPTION: Properties on class Named
| Name     | Type | Cardinality | Notes                   |
|----------+------+-------------+-------------------------|
| =identity= | =Name= |           1 | The type of a model element's name. |

** Abstract Class Namespace
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation-namespace
:END:

A base class for model elements that contain other, named, elements. This can be thought of as a hash map, or
dictionary, where the name of the element becomes it's key.

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Namespace=/
#+END_HIERARCHY

*Generic Parameters:* =T extends Named=

#+CAPTION: Properties on class Namespace
| Name    | Type | Cardinality | Notes                                                |
|---------+------+-------------+------------------------------------------------------|
| =members= | =T=    | 0..*        | members must have unique names within the namespace. |

** Abstract Class Type
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation-type
:END:

The base class of all model elements that may be treated as types. All types are named.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ∘ /=Type=/
    - ⏷ /=Datatype=/
    - ⏷ =Enum=
    - ⏷ =MappingType=
    - ⏷ =SequenceType=
    - ⏷ =Structure=
      - ⏷ =Entity=
      - ⏷ =Event=
    - ⏷ =Union=
#+END_HIERARCHY

*Super-Class:* =Named=

#+CAPTION: Properties on class Type
| Name    | Type  | Cardinality | Notes                                       |
|---------+-------+-------------+---------------------------------------------|
| =members= | =Typed= | 0..*        | The model elements declared with this type. |
|         |       |             |                                             |

** Abstract Class Typed
:PROPERTIES:
:CUSTOM_ID: mmodel:foundation-typed
:END:

A base class for model elements that are typed, and therefore have a association to a type.
*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Typed=/
#+END_HIERARCHY

#+CAPTION: Properties on class Typed
| Name | Type | Cardinality | Notes |
|------+------+-------------+---------|
| =type= | =Type= | 1..*        | The type, or types, of this model element. |

* Package Modules
:PROPERTIES:
:CUSTOM_ID: mmodel:modules
:END:

#+NAME: src:metamodel-models
#+BEGIN_SRC plantuml :file ./metamodel-models.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Definition
    abstract class "Namespace<T extends Named>" as g_Namespace
}

package Modules {
    class "Module<T=ModuleDefinition>" as g_Module {}
    abstract class ModuleDefinition {}
        
    g_Module -up-|> Definition
    g_Module -down-|> g_Namespace
    g_Module .down.> ModuleDefinition

    ModuleDefinition -up-|> Definition

    abstract class Import
    class ModuleImport
    class ModuleDefinitionImport

    g_Module -> "+imports\n0..*" Import
    ModuleImport -up-|> Import
    ModuleImport -> "+import" g_Module
    ModuleDefinitionImport -up-|> Import
    ModuleDefinitionImport -> "+import" ModuleDefinition
}

Modules .up.> Foundation: <<import>>
@enduml
#+END_SRC

#+NAME: fig:metamodel-models
#+CAPTION: The Modules Package
#+RESULTS: src:metamodel-models
[[file:./metamodel-models.svg]]

** Abstract Class Import
:PROPERTIES:
:CUSTOM_ID: mmodel:mod-import
:END:

A association from a module to another module, or module definition, to make it available for use.

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Import=/
      - ⏷ =ModuleImport=
      - ⏷ =ModuleDefinitionImport=
#+END_HIERARCHY

** Class Module
:PROPERTIES:
:CUSTOM_ID: mmodel:mod-module
:END:

A named set of related definitions. The module is a namespace for top-level definitions that are therefore name-unique
within the module.
*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
- ⏶ /=Namespace<T=ModuleDefinition>=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ∘ =Module=
#+END_HIERARCHY

#+CAPTION: Properties on class Module
| Name     | Type   | Cardinality | Notes |
|----------+--------+-------------+-------|
| =+imports= | =Import= | =0..*=      | The set of imported definitions. |

** Abstract Class Module Definition
:PROPERTIES:
:CUSTOM_ID: mmodel:mod-module-definition
:END:

A module-level, or top-level, definition is one that is directly a member of a module.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ∘ /=ModuleDefinition=/
      - ⏷ /=Datatype=/ ...
      - ⏷ =Enum=
      - ⏷ =MappingType=
      - ⏷ =Property=
      - ⏷ =SequenceType=
      - ⏷ =Structure=
        - ⏷ =Entity=
        - ⏷ =Event=
      - ⏷ =TypeClass=
      - ⏷ =Union=
#+END_HIERARCHY

** Abstract Class Module Definition Import
:PROPERTIES:
:CUSTOM_ID: mmodel:mod-definition-import
:END:

A association from a module to an external module definition to make it available for use.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Import=/
  - ∘ =ModuleDefinitionImport=
#+END_HIERARCHY

#+CAPTION: Properties on class Module Definition Import
| Name    | Type             | Cardinality | Notes                          |
|---------+------------------+-------------+--------------------------------|
| =+import= | =ModuleDefinition= | =1=           | An imported module definition. |

** Abstract Class Module Import
:PROPERTIES:
:CUSTOM_ID: mmodel:mod-module-import
:END:

A association from a module to another module to make it's definitions available for use.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Import=/
  - ∘ =ModuleImport=
#+END_HIERARCHY

#+CAPTION: Properties on class Module Import
| Name    | Type   | Cardinality | Notes               |
|---------+--------+-------------+---------------------|
| =+import= | =Module= | =1=           | An imported module. |

* Package Annotations
:PROPERTIES:
:CUSTOM_ID: mmodel:annotations
:END:

#+NAME: src:metamodel-annotations
#+BEGIN_SRC plantuml :file ./metamodel-annotations.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Definition
    abstract class Named
    abstract class Typed
}

package Datatypes {
    hide members
    class Boolean
}

package Values {
    hide members
    class Valued
}

package Annotations {
    abstract class Annotation {}
    Annotation -up-|> Named
    
    class AnnotationProperty {}
    AnnotationProperty -up-|> Annotation
    AnnotationProperty -up-|> Valued
    
    abstract class Constraint
    Constraint -up-|> Annotation
    Constraint -up-|> Typed
    Constraint --> "{subsets type}" Boolean

    abstract class Annotated {}
    Annotated "subject\l1" *--right--> "\rannotations\r0..*" Annotation
    Definition -up-|> Annotated
}

Annotations .up.> Foundation: <<import>>
Annotations .left.> Values: <<import>>
@enduml
#+END_SRC

#+NAME: fig:metamodel-annotations
#+CAPTION: The Annotations Package
#+RESULTS: src:metamodel-annotations
[[file:./metamodel-annotations.svg]]

** Abstract Class Annotated
:PROPERTIES:
:CUSTOM_ID: mmodel:ann-annotated
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Annotated=/
  - ⏷ /=Definition=/
#+END_HIERARCHY

#+CAPTION: Properties on class Annotated
| Name        | Type       | Cardinality | Notes |
|-------------+------------+-------------+---------|
| =annotations= | =Annotation= | 0..*        |         |

** Abstract Class Annotation
:PROPERTIES:
:CUSTOM_ID: mmodel:ann-annotation
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ∘ /=Annotation=/
    - ⏷ /=AnnotationProperty=/
    - ⏷ /=Constraint=/
      - ⏷ =FormalConstraint=
      - ⏷ =InformalControlledLanguageConstraint=
      - ⏷ =InformalNaturalLanguageConstraint=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Annotation
| Name   | Type      | Cardinality | Notes |
|--------+-----------+-------------+---------|
| =subject= | =Annotated= |           1 |         |

** Class Annotation Property
:PROPERTIES:
:CUSTOM_ID: mmodel:ann-annotation-property
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Annotation=/
  - ⏶ /=Valued=/
    - ∘ =AnnotationProperty=
#+END_HIERARCHY

#+CAPTION: Properties on class Annotation Property
| Name  | Type  | Cardinality | Notes |
|-------+-------+-------------+---------|
| =value= | =Value= |           1 |         |

** Abstract Class Constraint
:PROPERTIES:
:CUSTOM_ID: mmodel:ann-constraint
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Annotation=/
  - ⏶ /=Valued=/
    - ∘ /=Constraint=/
      - ⏷ =FormalConstraint=
      - ⏷ =InformalControlledLanguageConstraint=
      - ⏷ =InformalNaturalLanguageConstraint=
#+END_HIERARCHY

* Package Datatypes
:PROPERTIES:
:CUSTOM_ID: mmodel:datatypes
:END:

#+NAME: src:metamodel-datatypes
#+BEGIN_SRC plantuml :file ./metamodel-datatypes.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    class Name {}
    abstract class Type {}
}

package Modules {
    hide members
    abstract class ModuleDefinition {}
}

package Datatypes {
    abstract class Datatype {}
    Datatype -up-|> Type
    Datatype -up-|> ModuleDefinition

    Datatype ---> "restricts\r0..1" Datatype
    
    class Binary {}
    Binary -up-|> Datatype
    class Boolean {}
    Boolean -up-|> Datatype
    class Decimal {}
    Decimal -up-|> Datatype
    class Double {}
    Double -up-|> Datatype
    class Integer{}
    Integer -up-|> Datatype
    class String{}
    String -up-|> Datatype
    class Unsigned{}
    Unsigned -up-|> Datatype
    class Uri{}
    Uri -up-|> Datatype

    class LanguageTag {}
    class LanguageTaggedString {}
    LanguageTaggedString -up-|> String
    LanguageTaggedString *---right---> "+tag\r1" LanguageTag

    Name -up-|> String
}

Datatypes .up.> Foundation: <<import>>
Datatypes .up.> Modules: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Datatypes Package
#+RESULTS: src:metamodel-datatypes
[[file:./metamodel-datatypes.svg]]

#+NAME: src:metamodel-datatype-languages
#+BEGIN_SRC plantuml :file ./metamodel-datatype-languages.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package iso_639 {
    hide members
    enum LanguageCodeTwoChar {}
    enum LanguageCodeThreeChar {}
    enum LanguageSubTagCode {}
}

package iso_15924 {
    hide members
    enum ScriptCode {}
}

package iso_3166 {
    hide members
    enum RegionCodeTwoCharacter {}
}

package un_m49 {
    hide members
    enum RegionNumericCode {}
}

package Datatypes {

    enum LanguageCode {}
    LanguageCodeTwoChar -up-|> LanguageCode
    LanguageCodeThreeChar -up-|> LanguageCode

    enum RegionCode {}
    RegionCodeTwoCharacter -up-|> RegionCode
    RegionNumericCode -up-|> RegionCode
    LanguageSubTagCode -up-|> RegionCode
    
    class LanguageTag {}
    LanguageTag *-> "+language\n" LanguageCode
    LanguageTag *-> "+extended\r0..3\r" LanguageCodeThreeChar
    LanguageTag *-> "\r+script\r0..1" ScriptCode
    LanguageTag *-> "+region\r0..1\r" RegionNumericCode
}

Datatypes .down.> iso_639: <<import>>
Datatypes .up.> iso_15924: <<import>>
Datatypes .down.> iso_3166: <<import>>
Datatypes .down.> un_m49: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Datatype Languages Tag Detail
#+RESULTS: src:metamodel-datatype-languages
[[file:./metamodel-datatype-languages.svg]]

** Class Datatype
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-datatype
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ /=Datatype=/
#+END_HIERARCHY

** Class Binary
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-binary
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Binary=
#+END_HIERARCHY

** Class Boolean
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-boolean
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Boolean=
#+END_HIERARCHY

** Class Decimal
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-decimal
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Decimal=
#+END_HIERARCHY

** Class Double
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-double
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Double=
#+END_HIERARCHY

** Class Integer
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-integer
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Integer=
#+END_HIERARCHY

** Class String
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-string
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =String=
          - ⏷ =Name=
          - ⏷ =LanguageTaggedString=
#+END_HIERARCHY

** Class Unsigned
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-unsigned
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Unsigned=
#+END_HIERARCHY

** Class Uri
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-uri
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ∘ =Uri=
#+END_HIERARCHY

** Class Language Tag
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-language-tag
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ =LanguageTag=
#+END_HIERARCHY

#+CAPTION: Properties on class LanguageTag
| Name                  | Type   | Cardinality | Notes |
|-----------------------+--------+-------------+---------|
| =language= | =String=    |        1    |         |

** Class Language Tagged String
:PROPERTIES:
:CUSTOM_ID: mmodel:dt-language-tagged-string
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ /=Datatype=/
        - ⏶ =String=
          - ∘ =LanguageTaggedString=
#+END_HIERARCHY

#+CAPTION: Properties on class LanguageTaggedString
| Name                  | Type   | Cardinality | Notes |
|-----------------------+--------+-------------+---------|
| =tag=   | =LanguageTag=          |        1    |         |

* Package Sequence Types
:PROPERTIES:
:CUSTOM_ID: mmodel:sequence-types
:END:

#+NAME: src:metamodel-sequences
#+BEGIN_SRC plantuml :file ./metamodel-sequences.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Type {}
}

package Modules {
    hide members
    abstract class ModuleDefinition {}
}

package Values {
    hide members
    class Unsigned {}
}

package SequenceTypes {
    class Cardinality {
        +ordering: Ordering = Unordered
        +uniqueness: Uniqueness = Nonunique
        +min_length: Unsigned
        +max_length: 0..1 Unsigned
    }
    
    class "SequenceType<T extends Type>" as g_Sequence {
        +values: 0..* T
    }
    
    enum Ordering {
        +Unordered
        +Ordered
    }
    
    enum Uniqueness {
        +Unique
        +Nonunique
    }

    g_Sequence -up-|> Type
    g_Sequence .up.> Type
    g_Sequence -up-|> ModuleDefinition
    g_Sequence *-down-> "+cardinality\r1" Cardinality
}

SequenceTypes .up.> Foundation: <<import>>
SequenceTypes .up.> Modules: <<import>>
SequenceTypes .down.> Values: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Sequence Types Package
#+RESULTS: src:metamodel-sequences
[[file:./metamodel-sequences.svg]]

** Class Cardinality
:PROPERTIES:
:CUSTOM_ID: mmodel:seq-cardinality
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ =Cardinality=
#+END_HIERARCHY

#+CAPTION: Properties on class Cardinality
| Name       | Type       | Cardinality | Default   |
|------------+------------+-------------+-----------|
| =ordering=   | =Ordering=   |           1 | =Unordered= |
| =uniqueness= | =Uniqueness= |           1 | =Nonunique= |
| =min_length= | =Unsigned=   |           1 | 0         |
| =max_length= | =Unsigned=   |        0..1 |           |

** Enumeration Ordering
:PROPERTIES:
:CUSTOM_ID: mmodel:seq-ordering
:END:

*Variants*

- Ordered :: ...
- Unordered :: ...

** Class Sequence Type
:PROPERTIES:
:CUSTOM_ID: mmodel:seq-sequence-type
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ =SequenceType=
#+END_HIERARCHY

*Generic Parameters:* =T extends Type=

#+CAPTION: Properties on class SequenceType
| Name        | Type        | Cardinality | Notes |
|-------------+-------------+-------------+---------|
| =cardinality= | =Cardinality= | 1           |         |
| =values=      | =T=           | 0..*        |         |

** Enumeration Uniqueness
:PROPERTIES:
:CUSTOM_ID: mmodel:seq-uniqueness
:END:

*Variants*

- Nonunique :: ...
- Unique :: ...

* Package Product Types
:PROPERTIES:
:CUSTOM_ID: mmodel:product-types
:END:

#+NAME: src:metamodel-product-types
#+BEGIN_SRC plantuml :file ./metamodel-product-types.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Definition
    abstract class Named
    abstract class "Namespace<T extends Named>" as g_Namespace {}
    abstract class Type
    abstract class Typed
}

package Modules {
    hide members
    abstract class ModuleDefinition
}

package ProductTypes {
    class Entity
    class Event {}
    class "Structure<T=Member>" as g_Structure
    abstract class Member
    class MemberGroup

    g_Structure -up-|> Type
    g_Structure -up-|> ModuleDefinition
    g_Structure -up-|> g_Namespace
    g_Structure ..> Member
    g_Structure "+owner\l1" *--> "+groups\r0..*" MemberGroup
    
    Entity -up-|> g_Structure
    Entity *---right--> "+identity\r1" Member
    
    Event -up-|> g_Structure
    Event --> "+source\r1" Entity

    Member -up-|> Named
    MemberGroup -up-|> Annotated
    MemberGroup o--> "+members\r1..*" Member

    class MemberDefinition {}
    MemberDefinition -up-|> Definition
    MemberDefinition -up-|> Member
    MemberDefinition -up-|> Typed

    class "Property<T=Role>" as g_Property
    class Role {
        +is_identity: boolean = false
    }

    g_Property -up-|> ModuleDefinition
    g_Property -up-|> g_Namespace
    g_Property ..> Role
    Role -up-|> Definition
    Role -up-|> Typed
    
    class MemberReference {
        role: Role
    }
    MemberReference -up-|> Member

    ' TODO: Add features
}

ProductTypes .up.> Foundation: <<import>>
ProductTypes .up.> Modules: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Product Types Package
#+RESULTS: src:metamodel-product-types
[[file:./metamodel-product-types.svg]]

** Class Entity
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-entity
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=Member>=/
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ =Structure=
        - ∘ =Entity=
#+END_HIERARCHY

#+CAPTION: Properties on class Entity
| Name     | Type     | Cardinality | Notes |
|----------+----------+-------------+---------|
| =identity= | =Member= |           1 |         |

** Class Event
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-event
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=Member>=/
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ⏶ =Structure=
        - ∘ =Event=
#+END_HIERARCHY

#+CAPTION: Properties on class Event
| Name   | Type  | Cardinality | Notes |
|--------+-------+-------------+---------|
| =source= | =Event= |           1 |         |

** Abstract Class Member
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-member
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ∘ =Member=
#+END_HIERARCHY

** Class Member Definition
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-definition
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
- ⏶ /=Typed=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=Member=/
      - ∘ =MemberDefinition=
#+END_HIERARCHY

** Class Member Group
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-member-group
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Annotated=/
  - ∘ =MemberGroup=
#+END_HIERARCHY

#+CAPTION: Properties on class MemberGroup
| Name   | Type  | Cardinality | Notes |
|--------+-------+-------------+---------|
| =members= | =Member= | unique 1..* |         |

** Class Member Reference
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-member-reference
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Member=/
    - ∘ =MemberReference=
#+END_HIERARCHY

#+CAPTION: Properties on class MemberReference
| Name   | Type | Cardinality | Notes |
|--------+------+-------------+---------|
| =+role= | =Role= |           1 |         |

** Class Property
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-property
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=Role>=/
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ =Property=
#+END_HIERARCHY

** Class Role
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-role
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Typed=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ∘ =Role=
#+END_HIERARCHY

#+CAPTION: Properties on class Role
| Name         | Type    | Cardinality | Notes |
|--------------+---------+-------------+---------|
| =+is_identity= | =boolean= |           1 | =false=   |

** Class Structure
:PROPERTIES:
:CUSTOM_ID: mmodel:prod-structure
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=Member>=/
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ =Structure=
        - ⏷ =Entity=
        - ⏷ =Event=
#+END_HIERARCHY

#+CAPTION: Properties on class Entity
| Name   | Type  | Cardinality | Notes |
|--------+-------+-------------+---------|
| =+groups= | =MemberGroup= | unique 0..* |         |

* Package Sum Types
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-types
:END:

#+NAME: src:metamodel-sum-types
#+BEGIN_SRC plantuml :file ./metamodel-sum-types.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Named {}
    abstract class "Namespace<T extends Named>" as g_Namespace {}
    abstract class Type {}
    abstract class Typed {}
}

package Modules {
    hide members
    abstract class ModuleDefinition {}
}

package Values {
    hide members
    abstract class Valued {}
}

package SumTypes {
    class "Enum<T=ValueVariant>" as g_Enum {}
    class "Union<T=TypeVariant>" as g_Union {}

    g_Enum -up-|> Type
    g_Enum -up-|> ModuleDefinition
    g_Enum -up-|> g_Namespace

    g_Union -up-|> Type
    g_Union -up-|> ModuleDefinition
    g_Union -up-|> g_Namespace

    abstract class Variant {}
    class TypeVariant {}
    class ValueVariant {}

    Variant -up-|> Named
    TypeVariant -up-|> Variant
    TypeVariant -up-|> Typed
    ValueVariant -up-|> Variant
    ValueVariant -up-|> Valued

    class "MappingType<K extends SimpleType,\nV extends Type>" as g_MappingType {
        key: K
        value: V
    }
    g_MappingType -up-|> Type
}

SumTypes .up.> Foundation: <<import>>
SumTypes .up.> Values: <<import>>
SumTypes .down.> Modules: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Sum Types Package
#+RESULTS: src:metamodel-sum-types
[[file:./metamodel-sum-types.svg]]

** Class Enum
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-enum
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=TypeVariant>=/
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ =Enum=
#+END_HIERARCHY

** Class Mapping Type
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-mapping-type
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Type=/
    - ∘ =MappingType=
#+END_HIERARCHY

*Generic Parameters* =K extends SimpleType=, =V extends Type=

#+CAPTION: Properties on class MappingType
| Name  | Type | Cardinality | Notes |
|-------+------+-------------+---------|
| =key=   | =K=    |           1 |         |
| =value= | =V=    |           1 |         |

** Class Type Variant
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-type-variant
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
- ⏶ /=Named=/
  - ⏶ /=Variant=/
    - ∘ /=TypeVariant=/
#+END_HIERARCHY

** Class Union
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-union
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=TypeVariant>=/
- ⏶ /=Named=/
  - ⏶ /=Type=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ =Union=
#+END_HIERARCHY

** Abstract Class Variant
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-variant
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - /=Variant=/
#+END_HIERARCHY

** Class Value Variant
:PROPERTIES:
:CUSTOM_ID: mmodel:sum-value-variant
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Variant=/
    - ∘ ValueVariant
#+END_HIERARCHY

* Package Values
:PROPERTIES:
:CUSTOM_ID: mmodel:values
:END:

#+NAME: src:metamodel-values
#+BEGIN_SRC plantuml :file ./metamodel-values.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Type {}
    abstract class Typed {}
}

package Datatypes {
    hide members
    class Binary {}
    class Boolean {}
    class Decimal {}
    class Double {}
    class Integer {}
    class String {}
    class LanguageTaggedString {}
    class Unsigned {}
    class Uri {}
}

package SequenceTypes {
    hide members
    class "SequenceType<T extends Type>" as g_Sequence {}    
}

package SumTypes {
    hide members
    class "MappingType<K extends Type,\nV extends Type>" as g_MappingType   
}

package Values {
    abstract class Value {}
    Value -up-|> Typed

    abstract class Valued {}
    Valued ---left---> "+value\l1" Value
    
    abstract class SimpleValue {}
    SimpleValue -up-|> Value
    
    class BinaryValue {}
    BinaryValue -up-|> SimpleValue
    BinaryValue --down--> "{subsets type}" Binary
    
    class BooleanValue {}
    BooleanValue -up-|> SimpleValue
    BooleanValue --down--> "{subsets type}" Boolean
    
    class DecimalValue {}
    DecimalValue -up-|> SimpleValue
    DecimalValue --down--> "{subsets type}" Decimal
    
    class DoubleValue {}
    DoubleValue -up-|> SimpleValue
    DoubleValue --down--> "{subsets type}" Double
    
    class IntegerValue {}
    IntegerValue -up-|> SimpleValue
    IntegerValue --down--> "{subsets type}" Integer
    
    class StringValue {}
    StringValue -up-|> SimpleValue
    StringValue --down--> "{subsets type}" String
    
    class LanguageTaggedStringValue {}
    LanguageTaggedStringValue -up-|> StringValue
    LanguageTaggedStringValue --down--> "{subsets type}" LanguageTaggedString
    
    class UnsignedValue {}
    UnsignedValue -|> SimpleValue
    UnsignedValue --down--> "{subsets type}" Unsigned
    
    class UriValue {}
    UriValue -|> SimpleValue
    UriValue --down--> "{subsets type}" Uri

    class "MappingValue<Kv extends SimpleValue,\nVv extends Value>" as g_Mapping {
        +key: Kv
        +value: Vv
    }
    g_Mapping -up-|> Value
    g_Mapping --up--> "{subsets type}" g_MappingType: "K=type(Kv),\nV=type(Vv)"

    class "SequenceValue<V extends Value>" as g_SequenceValue {
        +values: {0..*} V
    }
    g_SequenceValue -up-|> Value
    g_SequenceValue --up--> "{subsets type}" g_Sequence: "T=type(V)"

    class ValueConstructor
    ValueConstructor -|> Value
    ValueConstructor --> "+target_type\r1" Type
    ValueConstructor --> "+source_value\r1" SimpleValue
}

Values .up.> Foundation: <<import>>
Values .down.> Datatypes: <<import>>
Values .down.> SequenceTypes: <<import>>
Values .down.> SumTypes: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Values Package
#+RESULTS: src:metamodel-values
[[file:./metamodel-values.svg]]

** Class Binary Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-binary-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =BinaryValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Binary Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Binary= |           1 |         |

** Class Boolean Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-boolean-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =BooleanValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Boolean Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Boolean=      |           1 |         |

** Class Decimal Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-decimal-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =DecimalValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Decimal alue
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Decimal=      |           1 |         |

** Class Double Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-double-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =Doublealue=
#+END_HIERARCHY

#+CAPTION: Properties on class Double Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Double=      |           1 |         |

** Class Integer Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-integer-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =IntegerValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Integer Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Integer=      |           1 |         |

** Class Mapping Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-mapping-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ∘ =MappingValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Mapping Value
| Name              | Type        | Cardinality | Notes |
|-------------------+-------------+-------------+---------|
| ={subsets} +domain= | =MappingType= |           1 |         |

** Class Sequence Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-sequence-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ∘ =SequenceValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Sequence Value
| Name              | Type         | Cardinality | Notes |
|-------------------+--------------+-------------+---------|
| ={subsets} +domain= | =SequenceType= |           1 |         |

** Abstract Class Simple Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-simple-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ∘ /SimpleValue=/
#+END_HIERARCHY

** Class String Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-string-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =StringValue=
#+END_HIERARCHY

#+CAPTION: Properties on class String Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =String=      |           1 |         |

** Class Unsigned Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-unsigned-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =UnsignedValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Unsigned Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Unsigned= |           1 |         |

** Class Uri Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-uri-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ⏶ /=Value=/
    - ⏶ /=SimpleValue=/
      - ∘ =UriValue=
#+END_HIERARCHY

#+CAPTION: Properties on class Uri Value
| Name                | Type | Cardinality | Notes |
|---------------------+------+-------------+---------|
| ={subsets} +domain= | =Uri=      |           1 |         |

** Abstract Class Value
:PROPERTIES:
:CUSTOM_ID: mmodel:v-value
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
  - ∘ /=Value=/
#+END_HIERARCHY

* Package Formal Constraints
:PROPERTIES:
:CUSTOM_ID: mmodel:formal-constraints
:END:

#+NAME: src:metamodel-constraints
#+BEGIN_SRC plantuml :file ./metamodel-constraints.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
skinparam ranksep 50
hide methods

package Annotations {
    hide members
    abstract class Constraint {}
}

package Datatypes {
    hide members
    class LanguageTaggedString
}

package Constraints {
    package Environments {
        abstract class EnvironmentDefinition
    }
    package Sentences {
        hide members
        abstract class Sentence {}    
    }
    package Terms {
        skinparam packageBackgroundColor transparent
    }
    
    class InformalNaturalLanguageConstraint {}
    InformalNaturalLanguageConstraint -up-|> Constraint
    InformalNaturalLanguageConstraint *-up-> "\r+text" LanguageTaggedString

    class ConstraintLanguageTag {
        +natural_language: 0..1 String
        +controlled_language: 0..1 String
    }
    class InformalControlledLanguageConstraint {
        +text: String
    }
    InformalControlledLanguageConstraint -up-|> Constraint
    InformalControlledLanguageConstraint *-down-> "+language" ConstraintLanguageTag

    class FormalConstraint
    FormalConstraint -up-|> Constraint
    FormalConstraint "+in_constraint" *---> "+sentence\n\n" Sentence
    FormalConstraint "+in_constraint" *---> "+environment\r*\r\r" EnvironmentDefinition
}
Constraints .up.> Annotations: "<<import>>"
Constraints .up.> Datatypes: "<<import>>"
@enduml
#+END_SRC

#+CAPTION: The Constraints Package
#+RESULTS: src:metamodel-constraints
[[file:./metamodel-constraints.svg]]

** Class Constraint Language Tag
:PROPERTIES:
:CUSTOM_ID: mmodel:fc-constraint-language-tag
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ =ConstraintLanguageTag=
#+END_HIERARCHY

#+CAPTION: Properties on class Formal Constraint
| Name                  | Type   | Cardinality | Notes |
|-----------------------+--------+-------------+---------|
| =natural_language=      | =String= |        0..1 |         |
| =controlled_language= | =String= |        0..1 |         |

** Class Formal Constraint
:PROPERTIES:
:CUSTOM_ID: mmodel:fc-formal-constraint
:END:

This is a constraint described using a structured expression language based on ISO Common Logic.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Annotation=/
    - ⏶ /=Constraint=/
      - ∘ =FormalConstraint=
#+END_HIERARCHY

#+CAPTION: Properties on class Formal Constraint
| Name     | Type       | Cardinality | Notes |
|----------+------------+-------------+---------|
| =sentence= | =Sentence= |           1 |         |

** Class Informal Controlled Language Constraint
:PROPERTIES:
:CUSTOM_ID: mmodel:fc-informal-controlled-language-constraint
:END:

This is a constraint described informally using a controlled natural language (CNL).

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Annotation=/
    - ⏶ /=Constraint=/
      - ∘ =InformalControlledLanguageConstraint=
#+END_HIERARCHY

#+CAPTION: Properties on class Informal Controlled Language Constraint
| Name  | Type  | Cardinality | Notes |
|-------+-------+-------------+---------|
| =text= | =String= |           1 |         |

** Class Informal Natural Language Constraint
:PROPERTIES:
:CUSTOM_ID: mmodel:fc-informal-natural-language-constraint
:END:

This is a constraint described informally using plain language.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=Annotation=/
    - ⏶ /=Constraint=/
      - ∘ =InformalNaturalLanguageConstraint=
#+END_HIERARCHY

#+CAPTION: Properties on class Informal Natural Language Constraint
| Name  | Type  | Cardinality | Notes |
|-------+-------+-------------+---------|
| =text= | =String= |           1 |         |

* Package Constraint Sentences
:PROPERTIES:
:CUSTOM_ID: mmodel:constraint-sentences
:END:

#+NAME: src:metamodel-constraint-sentences-overview
#+BEGIN_SRC plantuml :file ./metamodel-constraint-sentences-overview.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide members

abstract class Sentence {}

abstract class Simple {}
Simple -up-|> Sentence
class Atomic {}
Atomic -up-|> Simple
abstract class Relational {}
Relational -up-|> Simple

abstract class Boolean {}
Boolean -up-|> Sentence
abstract class Unary {}
Unary -up-|> Boolean
abstract class Binary {}
Binary -up-|> Boolean

class Quantified {}
Quantified -up-|> Sentence
#+END_SRC

#+CAPTION: The Constraint Sentences Package Overview
#+RESULTS: src:metamodel-constraint-sentences-overview
[[file:./metamodel-constraint-sentences-overview.svg]]

#+NAME: src:metamodel-constraint-sentences-simple
#+BEGIN_SRC plantuml :file ./metamodel-constraint-sentences-simple.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Constraints {
    package Terms {
        hide members
        abstract class Term {}
    }
    package Sentences {
        abstract class Sentence {}
        Sentence "+nested\n0..*" --> "+parent\n0..1" Sentence
        
        abstract class Simple {}
        Simple -up-|> Sentence
        
        class Atomic {
            +predicate: Term
            +arguments: 0..* Term
        }
        Atomic -up-|> Simple

        abstract class Relational {
            +lhs: Term
            +rhs: Term
        }
        Relational -up-|> Simple
        
        class Equation {}
        class StrictInequation {}
        class LessThan {}
        class LessThanOrEqual {}
        class GreaterThan {}
        class GreaterThanOrEqual {}

        Equation -up-|> Relational
        StrictInequation -up-|> Relational
        LessThan -up-|> Relational
        LessThanOrEqual -up-|> Relational
        GreaterThan -up-|> Relational
        GreaterThanOrEqual -up-|> Relational
    }
    Sentences .up.> Term: "<<import>>"
}
@enduml
#+END_SRC

#+CAPTION: Constraint Simple Sentences
#+RESULTS: src:metamodel-constraint-sentences-simple
[[file:./metamodel-constraint-sentences-simple.svg]]

#+NAME: src:metamodel-constraint-sentences-boolean
#+BEGIN_SRC plantuml :file ./metamodel-constraint-sentences-boolean.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Constraints {
    package Sentences {
        abstract class Sentence {}
        Sentence "+nested\n0..*" --> "+parent\n0..1" Sentence
        
        abstract class Boolean {}
        Boolean -up-|> Sentence
        
        abstract class Unary {
            +rhs: Sentence {subsets nested}
        }
        Unary -up-|> Boolean

        abstract class Binary {
            +lhs: Sentence {subsets nested}
            +rhs: Sentence {subsets nested}
        }
        Binary -up-|> Boolean

        class Negation {}
        Negation -up-|> Unary

        class Conjunction {}
        class Disjunction {}
        class ExclusiveDisjunction {}
        class Implication {}
        class Biconditional {}

        Conjunction -up-|> BinaryBoolean
        Disjunction -up-|> BinaryBoolean
        ExclusiveDisjunction -up-|> BinaryBoolean
        Implication -up-|> BinaryBoolean
        Biconditional -up-|> BinaryBoolean
    }
}
@enduml
#+END_SRC

#+CAPTION: Constraint Boolean Sentences
#+RESULTS: src:metamodel-constraint-sentences-boolean
[[file:./metamodel-constraint-sentences-boolean.svg]]

#+NAME: src:metamodel-constraint-sentences-quantified
#+BEGIN_SRC plantuml :file ./metamodel-constraint-sentences-quantified.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Named {}
}

package Constraints {
    package Terms {
        hide members
        abstract class Term {}
    }
    package Sentences {
        abstract class Sentence {}
        Sentence "+nested\n0..*" --> "+parent\n0..1" Sentence
        
        class Quantified {
            +body: Sentence {subsets nested}
        }
        Quantified -|> Sentence
        Quantified "+sentence" *--> "+binding" QuantifiedVariableBinding

        enum Quantifier {
            Universal
            Existential
        }

        class QuantifiedVariable {
            sequence: Term
        }
        QuantifiedVariable -up-|> Named

        class QuantifiedVariableBinding {}
        QuantifiedVariableBinding *--> "+quantifier\r1" Quantifier
        QuantifiedVariableBinding *--> "+variable\r0..1" QuantifiedVariable

        note "<b>inv</b>:\nempty(variable) implies\n  self.sentence.in_constraint.subject" as qvb_self

        qvb_self ..> QuantifiedVariableBinding
    }
    Sentences .up.> Foundation: "<<import>>"
    Sentences .up.> Term: "<<import>>"
}
@enduml
#+END_SRC

#+CAPTION: Constraint Quantified Sentences
#+RESULTS: src:metamodel-constraint-sentences-quantified
[[file:./metamodel-constraint-sentences-quantified.svg]]

** Class Atomic
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-atomic
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ∘ =Atomic=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Atomic
| Name      | Type | Cardinality  | Notes |
|-----------+------+--------------+---------|
| =predicate= | =Term= | 1            |         |
| =arguments= | =Term= | ordered 0..* |         |

** Class Biconditional
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-biconditional
:END:

Corresponds the expression to =A <==> B=, or $A \iff B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ⏶ /=Binary=/
      - ∘ =Biconditional=
#+END_HIERARCHY

** Abstract Class Binary
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-binary
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ∘ /=Binary=/
      - ⏷ =Biconditional=
      - ⏷ =Conjunction=
      - ⏷ =Disjunction=
      - ⏷ =ExclusiveDisjunction=
      - ⏷ =Implication=
#+END_HIERARCHY

#+CAPTION: Properties on class Binary
| Name | Type     | Cardinality | Notes                           |
|------+----------+-------------+---------------------------------|
| =lhs=  | =Sentence= |           1 | Subsets the association =nested=. |
| =rhs=  | =Sentence= |           1 | Subsets the association =nested=. |

** Abstract Class Boolean
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-boolean
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ∘ /=Boolean=/
    - ⏷ /=Binary=/
      - ⏷ =Biconditional=
      - ⏷ =Conjunction=
      - ⏷ =Disjunction=
      - ⏷ =ExclusiveDisjunction=
      - ⏷ =Implication=
    - ⏷ /=Unary=/
      - ⏷ /=Negation=/
#+END_HIERARCHY

** Class Conjunction
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-conjunction
:END:

Corresponds the expression to =A and B=, or $A \land B$.

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ⏶ /=Binary=/
      - ∘ =Conjunction=
#+END_HIERARCHY
 
** Class Disjunction
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-disjunction
:END:

Corresponds the expression to =A or B=, or $A \lor B$.

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ⏶ /=Binary=/
      - ∘ =Disjunction=
#+END_HIERARCHY
 
** Class Equation
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-equation
:END:

Corresponds the expression to =A = B=, or $A = B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ⏶ /=Relational=/
      - ∘ =Equation=
#+END_HIERARCHY

** Class Exclusive Disjunction
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-exclusive-disjunction
:END:

Corresponds the expression to =A xor B=, or $A \veebar B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ⏶ /=Binary=/
      - ∘ =ExclusiveDisjunction=
#+END_HIERARCHY

** Class Greater Than
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-greater-than
:END:

Corresponds the expression to =A > B=, or $A \gt B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ⏶ /=Relational=/
      - ∘ =GreaterThan=
#+END_HIERARCHY

** Class Greater Than Or Equal
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-great-than-or-equal
:END:

Corresponds the expression to ~A >= B~, or $A \geq B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ⏶ /=Relational=/
      - ∘ =GreaterThanOrEqual=
#+END_HIERARCHY

** Class Implication
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-implication
:END:

Corresponds the expression to =A implies B=, or $A \implies B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ⏶ /=Binary=/
      - ∘ =Implication=
#+END_HIERARCHY

** Class Less Than
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-less-than
:END:

Corresponds the expression to ~A <= B~, or $A \lt B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ⏶ /=Relational=/
      - ∘ =LessThan=
#+END_HIERARCHY

** Class Less Than Or Equal
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-less-than-or-equal
:END:

Corresponds the expression to ~A <= B~, or $A \leq B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ⏶ /=Relational=/
      - ∘ =LessThanOrEqual=
#+END_HIERARCHY

** Class Negation
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-negation
:END:

Corresponds the expression to =not A=, or $\neg A$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ⏶ /=Unary=/
      - ∘ /=Negation=/
#+END_HIERARCHY

** Abstract Class Sentence
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-sentence
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Sentence=/
  - ⏷ /=Boolean=/
    - ⏷ /=Binary=/
      - ⏷ =Biconditional=
      - ⏷ =Conjunction=
      - ⏷ =Disjunction=
      - ⏷ =ExclusiveDisjunction=
      - ⏷ =Implication=
    - ⏷ /=Unary=/
      - ⏷ /=Negation=/
  - ⏷ =Quantified=
  - ⏷ /=Simple=/
    - ⏷ =Atomic=
    - ⏷ /=Relational=/
      - ⏷ =Equation=
      - ⏷ =GreaterThan=
      - ⏷ =GreaterThanOrEqual=
      - ⏷ =LessThan=
      - ⏷ =LessThanOrEqual=
      - ⏷ =StrictInequation=
#+END_HIERARCHY

#+CAPTION: Properties on class Sentence
| Name    | Type     | Cardinality | Notes                                               |
|---------+----------+-------------+-----------------------------------------------------|
| =+nested= | =Sentence= | 0..*        | Any sentences that are nested within this sentence. |
| =+parent= | =Sentence= | 0..1        | The parent of this sentence, if nested.             |

** Class Quantified
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-quantified
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ∘ =Quantified=
#+END_HIERARCHY

#+CAPTION: Properties on class Quantified
| Name     | Type                      | Cardinality | Notes |
|----------+---------------------------+-------------+-------|
| =+binding= | =QuantifiedVariableBinding= | =1=           |       |
| =+body=    | =Sentence=                  | =1=           |       |

** Class Quantified Variable
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-quantified-variable
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ∘ =QuantifiedVariable=
#+END_HIERARCHY

#+CAPTION: Properties on class Quantified Variable
| Name     | Type | Cardinality | Notes |
|----------+------+-------------+-------|
| =+sequence= | =Term= |           =1= | Identifies a term that yields a sequence to be iterated over. |

** Class Quantified Variable Binding
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-quantified-variable-binding
:END:

#+BEGIN_HIERARCHY
- ∘ =QuantifiedVariableBinding=
#+END_HIERARCHY

#+CAPTION: Properties on class Quantified Variable Binding
| Name        | Type               | Cardinality | Notes |
|-------------+--------------------+-------------+-------|
| =+quantifier= | =Quantifier=         | =1=           |       |
| =+variable=   | =QuantifiedVariable= | =1=         |       |

** Enum Quantifier
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-quantifier
:END:

- Universal :: Corresponds to the keyword ~forall~ or the operator ∀.
- Existential ::  Corresponds to the keyword ~exists~ or the operator ∃

** Abstract Class Relational
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-relational
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ∘ /=Relational=/
      - ⏷ =Equation=
      - ⏷ =GreaterThan=
      - ⏷ =GreaterThanOrEqual=
      - ⏷ =LessThan=
      - ⏷ =LessThanOrEqual=
      - ⏷ =StrictInequation=
#+END_HIERARCHY

#+CAPTION: Properties on class Relational
| Name | Type | Cardinality | Notes |
|------+------+-------------+---------|
| =lhs=  | =Term= |           1 |  Subsets the association =nested=.        |
| =rhs=  | =Term= |           1 |   Subsets the association =nested=.       |

** Abstract Class Simple
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-simple
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ∘ /=Simple=/
    - ⏷ =Atomic=
    - ⏷ /=Relational=/
      - ⏷ =Equation=
      - ⏷ =GreaterThan=
      - ⏷ =GreaterThanOrEqual=
      - ⏷ =LessThan=
      - ⏷ =LessThanOrEqual=
      - ⏷ =StrictInequation=
#+END_HIERARCHY

** Class Strict Inequation
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-strict-inequation
:END:

Corresponds the expression to ~A /= B~, or $A \ne B$.

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Simple=/
    - ⏶ =Atomic=
    - ⏶ /=Relational=/
      - ∘ =StrictInequation=
#+END_HIERARCHY

** Abstract Class Unary
:PROPERTIES:
:CUSTOM_ID: mmodel:cs-unary
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Sentence=/
  - ⏶ /=Boolean=/
    - ∘ /=Unary=/
      - ⏷ =Negation=
#+END_HIERARCHY

#+CAPTION: Properties on class Unary
| Name | Type     | Cardinality | Notes                           |
|------+----------+-------------+---------------------------------|
| =+rhs= | =Sentence= | =1=           | Subsets the association =nested=. |

* Package Constraint Terms
:PROPERTIES:
:CUSTOM_ID: mmodel:constraint-terms
:END:

#+NAME: src:metamodel-constraint-terms
#+BEGIN_SRC plantuml :file ./metamodel-constraint-terms.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    class Name {}
}

package Values {
    hide members
    abstract class Value {}
}

package Constraints {
    package Terms {

        abstract class Term {}

        Name -up-|> Term
        Value -up-|> Term

        class FunctionalTerm {
            +function: Term
            +arguments: 0..* Term
        }
        FunctionalTerm -up-|> Term

        class SequenceBuilder  {}
        SequenceBuilder -up-|> Term
        SequenceBuilder *--> "+variables" SequenceVariables
        SequenceBuilder *--> "+body" QuantifiedSentence

        abstract class SequenceVariables {}
        class SequenceVariableSet {
            names: {unique} 1..* Name
        }
        class MappingSequenceVariables {
            key: Name
            value: Name
        }

        SequenceVariableSet -up-|> SequenceVariables
        MappingSequenceVariables -up-|> SequenceVariables
    }
    Terms .up.> Name: "<<import>>"
    Terms .up.> Value: "<<import>>"
}
@enduml
#+END_SRC

#+CAPTION: The Constraint Terms Package
#+RESULTS: src:metamodel-constraint-terms
[[file:./metamodel-constraint-terms.svg]]

** Class Functional Term
:PROPERTIES:
:CUSTOM_ID: mmodel:ct-functional-term
:END:

Corresponds to ~function(...arguments)~ or $f(a_0,\cdots, a_n)$

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Term=/
  - ∘ =FunctionalTerm=
#+END_HIERARCHY

#+CAPTION: Properties on class FunctionalTerm
| Name      | Type | Cardinality | Notes |
|-----------+------+-------------+---------|
| =function=  | =Term= | 1           |         |
| =arguments= | =Term= | 0..*        |         |

** Class Mapping Sequence Variables
:PROPERTIES:
:CUSTOM_ID: mmodel:ct-mapping-sequence-variables
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=SequenceVariables=/
  - ∘ =MappingSequenceVariables=
#+END_HIERARCHY

*Super Class:* =SequenceVariables=

#+CAPTION: Properties on class MappingSequenceVariables
| Name  | Type | Cardinality | Notes |
|-------+------+-------------+---------|
| =key= | =Name= |           1 |         |
| =value= | =Name= |           1 |         |

** Class Sequence Builder
:PROPERTIES:
:CUSTOM_ID: mmodel:ct-sequence-builder
:END:

Corresponds to ~{a | forall a, id(a)}~
or $\left\{ a | \forall a id(a) \right\}$

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Term=/
  - ∘ =SequenceBuilder=
#+END_HIERARCHY

#+CAPTION: Properties on class SequenceBuilder
| Name      | Type                 | Cardinality | Notes |
|-----------+----------------------+-------------+---------|
| =variables= | =SequenceVariables=    |           1 |         |
| =body=      | =QuantifiedSentence= |           1 |         |

** Abstract Class Sequence Variables
:PROPERTIES:
:CUSTOM_ID: mmodel:ct-sequence-variables
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=SequenceVariables=/
#+END_HIERARCHY

** Class Sequence Variable Set
:PROPERTIES:
:CUSTOM_ID: mmodel:ct-sequence-variable-set
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=SequenceVariables=/
  - ∘ =SequenceVariableSet=
#+END_HIERARCHY

#+CAPTION: Properties on class SequenceVariableSet
| Name  | Type   | Cardinality  | Notes |
|-------+--------+--------------+---------|
| =names= | =Name= | unique  1..* |         |

** Abstract Class Term
:PROPERTIES:
:CUSTOM_ID: mmodel:ct-term
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=Term=/
  - ⏷ =FunctionalTerm=
  - ⏷ =Name=
  - ⏷ =SequenceBuilder=
  - ⏷ =Value=
#+END_HIERARCHY

* Package Constraint Environments
:PROPERTIES:
:CUSTOM_ID: mmodel:constraint-environments
:END:

#+NAME: src:metamodel-constraint-environments
#+BEGIN_SRC plantuml :file ./metamodel-constraint-environments.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 60
skinparam ranksep 60
hide methods

package Foundation {
    hide members
    abstract class Definition
    abstract class Named
    abstract class Typed
}

package Values {
    hide members
    abstract class Valued
}

package Constraints {
    package Sentences {
        hide members
        abstract class Sentence {}
    }
    package Environments {
        abstract class EnvironmentDefinition {}
        EnvironmentDefinition -up-|> Definition
        
        class Function {}
        Function -up-|> EnvironmentDefinition
        Function -up-|> Typed
        Function *--> "+body\n\n" Sentence

        class Parameter {}
        Parameter -up-|> Named
        Parameter -up-|> Typed
        Function *--> "+parameters\r*" Parameter

        class Constant {}
        Constant -up-|> EnvironmentDefinition
        Constant -up-|> Valued
    }
}
Constraints .up.> Foundation: "<<import>>"
Constraints .up.> Values: "<<import>>"
@enduml
#+END_SRC

#+CAPTION: The Constraint Environments Package
#+RESULTS: src:metamodel-constraint-environments
[[file:./metamodel-constraint-environments.svg]]

** Abstract Class Constant
:PROPERTIES:
:CUSTOM_ID: mmodel:ce-constant
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
- ⏶ /=Named=/
  - ⏶ /=EnvironmentDefinition=/
    - ∘ =Constant=
#+END_HIERARCHY

** Abstract Class Environment Definition
:PROPERTIES:
:CUSTOM_ID: mmodel:ce-environment-definition
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ∘ /=EnvironmentDefinition=/
    - ⏷ /=Constant=/
      - ⏷ =ConstantSentence=
      - ⏷ =ConstantValue=
    - ⏷ =Function=
#+END_HIERARCHY

** Class Function
:PROPERTIES:
:CUSTOM_ID: mmodel:ce-function
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ⏶ /=EnvironmentDefinition=/
    - ∘ =Function=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Function
| Name        | Type      | Cardinality | Notes |
|-------------+-----------+-------------+---------|
| =+body=       | =Sentence=  | 1           |         |
| =+parameters= | =Parameter= | 0..*        |         |

** Class Parameter
:PROPERTIES:
:CUSTOM_ID: mmodel:ce-parameter
:END:
 
*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
- ⏶ /=Typed=/
  - ∘ =Parameter=
#+END_HIERARCHY

* Package Type Classes
:PROPERTIES:
:CUSTOM_ID: mmodel:type-classes
:END:

#+NAME: src:metamodel-type-classes
#+BEGIN_SRC plantuml :file ./metamodel-type-classes.svg
@startuml
skinparam backgroundColor transparent
skinparam linetype polyline
skinparam nodesep 50
hide methods

package Foundation {
    hide members
    abstract class Definition {}
    abstract class Named {}
    abstract class "Namespace<T extends Named>" as g_Namespace {}
    abstract class Typed {}
}

package Modules {
    hide members
    abstract class ModuleDefinition {}
}

package Constraints {
    package Sentences {
        hide members
        abstract class Sentence {}
    }
}

package TypeClasses {
    class "TypeClass<T=Method>" as TypeClass {}
    class TypeVariable {}
    class TypeClassReference {}
    class ReferenceArgument {}
    class ReferenceWildcard {}
    class ReferenceList {}
    class Method {}
    class Parameter {}

    TypeClass -up-|> g_Namespace
    TypeClass ..> Method
    TypeClass -up-|> ModuleDefinition
    TypeClass *--left--> "+variables\l0..*" TypeVariable
    TypeClass *-down-> "+methods\r0..*" Method
    TypeVariable -up-|> Named
    TypeVariable *--> "+restrictions\r0..*" TypeClassReference

    TypeClassReference --> "+class" TypeClass
    TypeClassReference --> "+arguments" ReferenceArgument

    ReferenceWildcard -up-|> ReferenceArgument
    ReferenceList -up-|> ReferenceArgument
    ReferenceList --> "+classes\r1..*" TypeClassReference

    Method -up-|> Definition
    Method -up-|> Typed
    Method *-right-> "+body\r0..1\r\r" Sentence

    Parameter -up-|> Named
    Parameter -up-|> Typed
    Method *-down-> "+parameters\r0..*" Parameter
}

TypeClasses .up.> Foundation: <<import>>
TypeClasses .up.> Modules: <<import>>
TypeClasses .right.> Sentences: <<import>>
@enduml
#+END_SRC

#+CAPTION: The Type Classes Package
#+RESULTS: src:metamodel-type-classes
[[file:./metamodel-type-classes.svg]]

** Class Method
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-method
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
- ⏶ /=Named=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
      - ∘ =Method=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Method
| Name        | Type      | Cardinality | Notes |
|-------------+-----------+-------------+---------|
| =+parameters= | =Parameter= | 0..*        |         |
| =+body=       | =Sentence=  | 0..1        |         |

** Class Parameter
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-parameter
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Typed=/
- ⏶ /=Named=/
  - ∘ =Parameter=
#+END_HIERARCHY

** Class Reference Argument
:PROPERTIES:
:CUSTOM_ID: mmodel:reference-argument
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ /=ReferenceArgument=/
  - ⏷ =ReferenceList=
  - ⏷ =ReferenceWildcard=
#+END_HIERARCHY

** Class Reference List
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-reference-list
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=ReferenceArgument=/
  - ∘ =ReferenceList=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Type Class Reference
| Name       | Type              | Cardinality | Notes |
|------------+-------------------+-------------+---------|
| =+classes=   | =TypeClassReference=         | 1..*      |         |

** Class Reference Wildcard
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-reference-wildcard
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=ReferenceArgument=/
  - ∘ =ReferenceWildcard=
#+END_HIERARCHY

** Class Type Class
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-type-class
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Namespace<T=Method>=/
- ⏶ /=Named=/
- ⏶ /=Annotated=/
  - ⏶ /=Definition=/
    - ⏶ /=ModuleDefinition=/
      - ∘ =TypeClass=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Type Class
| Name       | Type         | Cardinality | Notes |
|------------+--------------+-------------+---------|
| =+variables= | =TypeVariable= | 0..*        |         |
| =+methods=   | =Method=       | 0..*        |         |

** Class Type Variable
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-type-variable
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ⏶ /=Named=/
  - ∘ =TypeVariable=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Type Variable
| Name          | Type               | Cardinality | Notes |
|---------------+--------------------+-------------+---------|
| =+restrictions= | =TypeClassReference= | 0..*        |         |

** Class Type Class Reference
:PROPERTIES:
:CUSTOM_ID: mmodel:tc-type-class-ref
:END:

*Hierarchy*

#+BEGIN_HIERARCHY
- ∘ =TypeClassReference=
#+END_HIERARCHY
 
#+CAPTION: Properties on class Type Class Reference
| Name       | Type              | Cardinality | Notes |
|------------+-------------------+-------------+---------|
| =+class=     | =TypeClass=         |           1 |         |
| =+arguments= | =ReferenceArgument= |           1 |         |
