#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:surface-syntax>>The Surface Syntax

This section describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation. The goal of the following syntax is to allow for rapid
capture of domain information but allowing elaboration of details over time. To this end we have made language features
optional wherever possible such that the minimum information neccessary is required to build a valid model. This
document will use the terms /valid/ to denote a model that has no syntactic errors and /complete/ to denote a valid model
that has no short-form, or /incomplete/, model elements.

The grammar, where possible, supports Unicode representations of keywords and operators that allow for formatting a
source module with more compact expressions. This is to obviate the need for separate type-setting tools that typically
perform a one-way transformation from source to some other format. See table [[tbl:unicode-characters]] in appendix
[[app:unicode]] for details.

For the complete grammar, and notes on BNF notation, see section [[sec:complete-grammar]].

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

#+BEGIN_SRC ebnf
Whitespace
    ::= [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]
#+END_SRC

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line. Comments are
intended to capture only information regarding the file contents and not model contents. Because of this, parsers are
*not* required to capture comments, and tools are *not* required to emit comments back into changed files. For persistent
comments within the model, relevant annotation properties may be attached to the model elements.

#+BEGIN_SRC ebnf
LineComment
    ::= ";" [^\r\n]*
#+END_SRC

[[./ebnf-diagram/LineComment.svg]]

#+NAME: lst:grammar-comment
#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
; <- comments start here and end here ->
#+END_SRC

In the following example ([[lst:sdml-ex-annotation-comment]]) a tool reading the following file is not required to preserve the comment, which in this case
is OK as the ~editorialNote~ will be preserved and correctly used for the same purpose.

#+NAME: lst:sdml-ex-annotation-comment
#+CAPTION: Example: Annotation Comments
#+BEGIN_SRC sdml :exports code :noeval
module foo is
  import [dc skos]

  ; Should come up with a better name.
  @skos:prefLabel = "Foo"@en
  @dc:description = "Here's a descriptive comment"
  @skos:editorialNode = "Someone should fix the name"
end
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the Unicode General Category[fn:ucgc] *Lu* (an uppercase letter),
*Ll* (a lowercase letter), *Nd* (decimal digit), or the Unicode Low Line (underscore, "_", =U+005F=) character. Specifically
an identifer *must* start with and *must* begin and end with a letter such that the low line character may only appear
/within/ the identifier.

The following is the BNF description of the identifier syntax.

#+BEGIN_SRC ebnf
Identifier
    ::= IdentifierInitial
        IdentifierChar* ( "_" IdentifierChar+ )*
#+END_SRC

[[./ebnf-diagram/Identifier.svg]]

#+BEGIN_SRC ebnf
IdentifierInitial
    ::= UC_LETTER_UPPER | UC_LETTER_LOWER
#+END_SRC

[[./ebnf-diagram/IdentifierInitial.svg]]

#+BEGIN_SRC ebnf
IdentifierChar
    ::= IdentifierInitial | UC_NUMBER_DECIMAL
#+END_SRC

[[./ebnf-diagram/IdentifierChar.svg]]

Naming Conventions:

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum and Union Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

*** Qualified Identifier

A qualified identifier comprises a module identifier followed by the Colon (":", =U+003A=) character and the identifier of
a member within that module.

#+BEGIN_SRC ebnf
QualifiedIdentifier
    ::= Identifier ":" Identifier
#+END_SRC

[[./ebnf-diagram/QualifiedIdentifier.svg]]

A type reference may be to a locally defined type by an identifier, or an imported type by a qualified identifier.

#+BEGIN_SRC ebnf
IdentifierReference
    ::= QualifiedIdentifier | Identifier
#+END_SRC

[[./ebnf-diagram/IdentifierReference.svg]]

** <<sec:modules-and-imports>> Module Definition and Imports

A module is the container for a set of type definitions and typically models a /Domain/ or /Sub-domain/. A single resource
(in the web sense of some /thing/ identified by an IRI) may contain only a single module; therefore, the smallest valid
resource is one with an empty module.

#+BEGIN_SRC ebnf
Module
    ::= "module" Identifier ModuleBase? ModuleBody
#+END_SRC

[[./ebnf-diagram/Module.svg]]

An empty module (listing [[lst:sdml-ex-empty-module]]) is any module with an empty /body/, delimited by the keywords *~is~* and
*~end~*.

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: Example: Empty Module
#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC

*** The base Specifier

#+BEGIN_SRC ebnf
ModuleBase
    ::= "base" IriReference
#+END_SRC

[[./ebnf-diagram/ModuleBase.svg]]

The keyword *~base~* provides the base IRI for the module and corresponding RDF schema or OWL ontology. This corresponds
to the use of the ~xml:base~ attribute in RDF/XML and the ~@base~ directive in Turtle and SPARQL[fn:sparql]. This IRI is
used as a prefix for defined type names so that each type has a unique IRI. The example in listing
[[lst:sdml-ex-module-base]] demonstrates the assigned IRI identifier for the structure type named ~Thing~.

#+NAME: lst:sdml-ex-module-base
#+CAPTION: Example: Empty Module with Base
#+BEGIN_SRC sdml :exports code :noeval
module example base <https://example.org/rdf/example#> is

  structure Thing
  ;; IRI: https://example.org/rdf/example#Thing

end
#+END_SRC

*Module URI Resolution*

Each module has an identifer/name defined within the module source as well as a base URI used to assign URIs to every
model element within the resource. This URI identifier for each model element necessary as the identifier for the
corresponding RDF resource(s). Our first problem is to determine the base URI for the module,as follows:

1. If the module has a base specifier it MUST be used as the module URI.
2. If the reader has access to an SDML catalog file (For details of the catalog file format see appendix
   [[sec:resolver-catalog]]), a matching catalog entry MUST be used as the module URI.
3. A URI is calculated for the module using the =file:= scheme and the file path relative to a /project root/.

Considering the following simple module in the file =vehicle.sdm=.

#+BEGIN_SRC sdml :exports code :noeval
module vehicle is end
#+END_SRC

If the following file is in the same directory as the vehicle module it is possible to   

#+BEGIN_SRC json :noeval
{
  "base": "https://example.org/rentals/",
  "entries": {
    "vehicle": {
      "item": {
        "relative_uri": "vehicle#",
        "relative_path": "vehicle-v1.sdm"
      }
    }
  }
}
#+END_SRC

*** Importing Modules and Members

#+BEGIN_SRC ebnf
ModuleBody
    ::= "is"
        ImportStatement* Annotation* Definition*
        "end"
#+END_SRC

[[./ebnf-diagram/ModuleBody.svg]]

To import types from other modules you add one or more import statements to the module body. Each statement may
reference one or more module names or the qualified name of a type within a module.

#+BEGIN_SRC ebnf
ImportStatement
    ::= "import" ( Import | "[" Import+ "]" )
Import
    ::= MemberImport | ModuleImport
#+END_SRC

[[./ebnf-diagram/ImportStatement.svg]]

[[./ebnf-diagram/Import.svg]]

Importing a module allows access to all members of that module using qualified identifiers. For example, importing
module ~sdml~ allows the reference of core types as ~sdml:string~ or ~sdml:decimal~.

#+BEGIN_SRC ebnf
ModuleImport
    ::= Identifer
#+END_SRC

[[./ebnf-diagram/ModuleImport.svg]]

Importing a module member directly still results in a qualified identifier, but makes the dependency clearer. For
example, in the case above if we are only using the ~string~ member from the ~sdml~ module importing ~sdml:string~ is cleaner.

#+BEGIN_SRC ebnf
MemberImport
    ::= QualifiedIdentifier
#+END_SRC

[[./ebnf-diagram/MemberImport.svg]]

The module in listing [[lst:sdml-ex-import-module]] contains a single import statement /referencing/ the module named =xsd=
making it's members /visible/ in the qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: Example: Importing Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import xsd

end
#+END_SRC

The module in listing [[lst:sdml-ex-import-member]] contains a single import statement /referencing/ the member named =integer= from
the module =xsd= making it visible.

#+NAME: lst:sdml-ex-import-member
#+CAPTION: Example: Importing Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import xsd:integer

end
#+END_SRC

To reduce the number of import statements a list of identifiers, both module and member, may be /referenced/ as a list.
Listing [[lst:sdml-ex-import-list]] makes the members =author= and =title= from the module =dc= visible. Lists in SDML start
with the Left Square Bracket ("[", =U+005B=) character and end with the Right Square Bracket ("]", =U+005D=) character with
no separator character between members of the list.

#+NAME: lst:sdml-ex-import-list
#+CAPTION: Example: Importing a List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc:title dc:author ]

end
#+END_SRC

*** Definitions

The members of a module are a set of definitions that may be combined to develop a domain model.

#+BEGIN_SRC ebnf
Definition
    ::= DataTypeDef
        | EntityDef
        | EnumDef
        | EventDef
        | PropertyDef
        | StructureDef
        | UnionDef
#+END_SRC

[[./ebnf-diagram/Definition.svg]]

Data types are further described in section [[sec:datatypes]]; entities, enumerations, events, structures, and disjoint
unions are described in section [[sec:structured-types]]; and properties are described in section [[sec:properties]].

*** Type Model

A subset of the definition types in the EBNF above are types, and the complete type model for SDML is shown in figure
[[fig:sdml-type-model]]. In this figure the following types exist that are not directly reified in the surface syntax.

- Any :: The root of our type system, or the type of /all individuals/. This is sometimes termed /top/ or a tautology ~⊤~.
- Scalar :: A scalar type refers to a data type whose individuals represent a single discrete value. In SDML all
  datatypes and enumerations are scalar types.
- Sum :: A type whose members are discrete but not necessarily scalar, i.e. it's individuals are either one member /or/
  another, but not both. In the case of SDML only disjoint unions are sum types.
- Product :: A type whose members are all present, i.e. it's individuals have one member /and/ another and so on. In SDML
  entities, events, and structures are product types.
- Unknown :: A pseudo-type that is applied when the author does not yet know what the type should be but wishes to
  create a valid model. In SDML member types may be defined as ~unknown~ during module development but such a type, and
  therefore it's containing module, is incomplete.
- None :: A type which represents the type of /zero individuals/ and is therefore invalid as a member type. This is
  sometimes termed /bottom/ or /absurdity/ ~⊥~.

#+NAME: lst:sdml-type-model
#+BEGIN_SRC dot :file ./images/sdml-type-model.svg :exports results
strict digraph {
   bgcolor="transparent";
   rankdir=BT;
   fontname="Helvetica,Arial,sans-serif";
   node [shape="rect"; fontname="Helvetica,Arial,sans-serif"; fontsize=10; width=1.0; height=0.4];
   edge [arrowhead=onormal; fontname="Helvetica,Arial,sans-serif"; fontsize=9; fontcolor="darkgrey"];
   
   Type [color="grey"; fontcolor="grey"; label="Any\n(⊤)"];
   Scalar -> Type;
   Scalar [color="grey"; fontcolor="grey"];
   Datatype -> Scalar;
   Sum [color="grey"; fontcolor="grey"];
   Sum -> Type;
   Enumeration -> Scalar;
   Union -> Sum;
   Product [color="grey"; fontcolor="grey"];
   Product -> Type;
   Entity -> Product;
   Event -> Product;
   Structure -> Product;
   Unknown [label="Unknown"];
   Unknown -> Type;
        
   None [color="grey"; fontcolor="grey"; label="None\n(⊥)"];
   None -> Datatype;
   None -> Enumeration;
   None -> Union;
   None -> Entity;
   None -> Event;
   None -> Structure;
}
#+END_SRC

#+NAME: fig:sdml-type-model
#+CAPTION: SDML Type Model
#+RESULTS: lst:sdml-type-model
[[file:./images/sdml-type-model.svg]]

*Sum vs. Product*

Given a type $T$ with members $m_1, \cdots m_n$, and a relation $\tau_{m_i}$ that returns the type of a value or definition, we can show
this mathematically as follows.

1. Because a sum type may only be one member *or* another at any time the number of potential values (shown below as the
   cardinality of the type) is the number of values in each member added together $m_1 + m_2 + \cdots m_n$.

   $$ \sum_{m \in T} |\tau_m| $$

1. Because a product type has it's first member *and* second *and* so on, the number of potential values is the number of
   values in each member multiplied together $m_1 \times m_2 \times \cdots m_n$. This is also known as the /Cartesian
   Product/ of the set $\{m_1, \cdots m_n\}$.

   $$ \prod_{m \in T} |\tau_m| $$

** <<sec:datatypes>>Data Types and Values

A data type /individual/, or simply a /value/, is either a simple value, a value constructor, an identifier reference, a
mapping value, or a list of values.

#+BEGIN_SRC ebnf
Value
    ::=  SimpleValue
        | ValueConstructor
        | IdentifierReference
        | MappingValue
        | SequenceOfValues
#+END_SRC

[[./ebnf-diagram/Value.svg]]

The inclusion of an identifier reference as a value allows for annotations whose value is another model element. It is
invalid to use the identifier of an individual that is not itself a value.

The core data types supported by SDML are ~boolean~, ~integer~, ~decimal~, ~double~, ~string~, (Language-Tagged String), and ~iri~
for IRI References. Values corresponding to these types are termed /simple values/.

#+BEGIN_SRC ebnf
SimpleValue
    ::= Boolean
        | Unsigned | Integer | Decimal| Double
        | String | Iri | Binary
#+END_SRC

[[./ebnf-diagram/SimpleValue.svg]]

These data types have corresponding keywords in SDML, and may have specific rules applied when parsing. Each keyword is
translated into a qualified identifier where the module name is the reserved name =sdml=. This set of standard library
types have an underlying RDF/OWL equivalence relationship to a subset of the XML Schema datatypes, all shown in table
[[tbl:builtin-simple-types]].

#+BEGIN_SRC ebnf
BuiltinSimpleType
    ::= "boolean"
        | "unsigned" | "integer" | "decimal" | "double"
        | "string" | "iri" | "binary"
#+END_SRC

[[./ebnf-diagram/BuiltinSimpleType.svg]]

#+NAME: tbl:builtin-simple-types
#+CAPTION: Built-in Simple Type Mapping
| Type Keyword | Qualified Identifier | Equivalent XML Schema Datatype |
|--------------+----------------------+--------------------------------|
| ~boolean~      | ~sdml:boolean~         | ~xsd:boolean~                    |
| ~unsigned~     | ~sdml:unsigned~        | ~xsd:unsignedLong~               |
| ~integer~      | ~sdml:integer~         | ~xsd:long~                       |
| ~decimal~      | ~sdml:decimal~         | ~xsd:decimal~                    |
| ~double~       | ~sdml:double~          | ~xsd:double~                     |
| ~iri~          | ~sdml:iri~             | ~xsd:anyURI~                     |
| ~string~       | ~sdml:string~          | ~xsd:string~ or ~rdf:langString~   |
| ~binary~       | ~sdml:binary~          | ~xsd:hexBinary~                  |

Some additional types are defined in the ~sdml~ module, although they are not considered built-in types as they must be
referenced explicitly.

#+NAME: tbl:additional-simple-types
#+CAPTION: Additional Simple Types in SDML
| Qualified Identifier | Equivalent XML Schema Datatype |
|----------------------+--------------------------------|
| ~sdml:u8~              | ~xsd:unsignedByte~               |
| ~sdml:i8~              | ~xsd:byte~                       |
| ~sdml:u16~             | ~xsd:unsignedShort~              |
| ~sdml:i16~             | ~xsd:short~                      |
| ~sdml:u32~             | ~xsd:unsignedInt~                |
| ~sdml:i32~             | ~xsd:int~                        |
| ~sdml:u64~             | ~xsd:unsignedLong~               |
| ~sdml:i64~             | ~xsd:long~                       |

*** Booleans

A /boolean/ value in SDML is either a truth value, or a falsity value. Other types are not coerced into boolean values as
they may be in other languages.

#+BEGIN_SRC ebnf
Boolean
    ::= Truth | Falsity
#+END_SRC

[[./ebnf-diagram/Boolean.svg]]

We denote a truth value with either the keyword ~true~ or the Down Tack ("⊤", =U+22A4=) character.

Truth
    ::= ( "true" | "⊤" )
#+END_SRC

[[./ebnf-diagram/Truth.svg]]

We denote a falsity value with either the keyword ~false~ or the Up Tack ("⊤", =U+22A5=) character.

#+BEGIN_SRC ebnf
Falsity
    ::= ( "false" | "⊥" )
#+END_SRC

[[./ebnf-diagram/Falsity.svg]]

*** Unsigned Integers

An /unsigned/ value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The unsigned type corresponds to a 64-bit unsigned integer number (values $[0, 2^{64}-1]$).

#+BEGIN_SRC ebnf
Unsigned
    ::= Zero | NonZero ASCII_DIGIT*
Zero
    ::= [0]
NonZero
    ::= [1-9]
#+END_SRC

[[./ebnf-diagram/Unsigned.svg]]

[[./ebnf-diagram/Zero.svg]]

[[./ebnf-diagram/NonZero.svg]]

*** Signed Integers

A /signed integer/ value in SDML consists of an optional a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+",
=U+002B=) followed by a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however =00= and =01=
are not. The integer type corresponds to a 64-bit signed integer number (values $[−2^{63}, 2^{63} − 1]$).

#+BEGIN_SRC ebnf
Integer
    ::= NumericSign? Unsigned
NumericSign
    ::= [+-]
#+END_SRC

[[./ebnf-diagram/Integer.svg]]

[[./ebnf-diagram/NumericSign.svg]]

*** Decimal Numbers

A /decimal/ (fixed point) value in SDML is an integer value, followed by the Full Stop (".", =U+002E=) character and another
integer-like value although this second value allows any number of leading zeros. The decimal type corresponds to a
128-bit representation of a fixed-precision decimal number.

#+BEGIN_SRC ebnf
Decimal
    ::= Integer "." ASCII_DIGIT+
#+END_SRC

*** Floating-Point Numbers

A /double/ value in SDML is a decimal-like value followed by a lower or upper case letter E (Latin Small Letter E, "e",
=U+0065= or Latin Capital Letter E, "E", =U+0045=), a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+", =U+002B=)
and an integer-like value. The double type is a 64-bit floating point number (specifically, the "binary64" type defined
in IEEE 754-2008).

#+BEGIN_SRC ebnf
Double
    ::= Decimal ExponentChar NumericSign? Integer
ExponentChar
    ::= [eE]
#+END_SRC

[[./ebnf-diagram/Double.svg]]

[[./ebnf-diagram/ExponentChar.svg]]

*** Character Strings

A /string/ value in SDML is a sequence of Unicode characters starting and ending with a Quotation Mark ('"', =U+0022=)
character. While standard escape sequences allow for embedding non-printing characters. 

#+BEGIN_SRC ebnf
String
    ::= QuotedString LanguageTag?
QuotedString
    ::= '"' ( Escape | NotAllowed )* '"'
NotAllowed
    ::= [^\"\#x00-#x08#x0B-#x1F#x7F]
#+END_SRC

[[./ebnf-diagram/String.svg]]

[[./ebnf-diagram/QuotedString.svg]]

[[./ebnf-diagram/NotAllowed.svg]]

Standard single-character escape forms are supported, described in table [[tbl:string-escape-characters]]. The form
=\u{XXXX}=, where =X= is a single hex digit, allows for the inclusion of any Unicode characters by their code point. Note
that this form requires a minimum of 2 and a maximum of 6 such digits.

#+BEGIN_SRC ebnf
Escape              ::= "\\" ( CharacterEscape | UnicodeEscape )
CharacterEscape     ::= [\"\\/abefnrtv]
UnicodeEscape       ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"
HexPair             ::= ASCII_HEX_DIGIT ASCII_HEX_DIGIT
#+END_SRC

[[./ebnf-diagram/Escape.svg]]

[[./ebnf-diagram/CharacterEscape.svg]]

[[./ebnf-diagram/UnicodeEscape.svg]]

[[./ebnf-diagram/HexPair.svg]]

Note also that strings allow literal newlines and do not /require/ they be present in escaped form. This means that a
string literal supports multiline forms.

#+NAME: tbl:string-escape-characters
#+CAPTION: String Escape Characters
| Escape Character | Character Name (Common Name)          | Unicode Equivalent |
|------------------+---------------------------------------+--------------------|
| =\"=               | Quotation Mark                        | =\u{0022}=           |
| =\/=               | Solidus (Forward Slash)               | =\u{002F}=           |
| =\\=               | Reverse Solidus (Backslash)           | =\u{005C}=           |
| =\a=               | Bell                                  | =\u{0007}=           |
| =\b=               | Backspace                             | =\u{0008}=           |
| =\e=               | Escape                                | =\u{001B}=           |
| =\f=               | Form Feed (Page Break)                | =\u{000C}=           |
| =\n=               | Line Feed (New Line)                  | =\u{000A}=           |
| =\r=               | Carriage Return                       | =\u{000D}=           |
| =\t=               | Character Tabulation (Horizontal Tab) | =\u{0009}=           |
| =\v=               | Line Tabulation (Vertical Tab)        | =\u{000B}=           |

A /language-tagged string/ value in SDML is a string as above but immediately followed by a Commercial At ("@", =U+0040=)
character and an unquoted string of characters that conform to a language identifier. Note that both components of such
a string contribute to equality tests, so that ="abc"@en= is not equal to ="abc"@fr=.

#+BEGIN_SRC ebnf
LanguageTag
    ::= "@"
        LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?
#+END_SRC

[[./ebnf-diagram/LanguageTag.svg]]

The primary language is one of:

- a two letter language code from ISO 639-1[fn:iso-639-1],
- a three letter code from ISO 639-2[fn:iso-639-2].

#+BEGIN_SRC ebnf
LanguageTagPrimary
    ::= ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?
#+END_SRC

[[./ebnf-diagram/LanguageTagPrimary.svg]]

The extended language is zero to three selected three letter ISO 639-2 codes.

#+BEGIN_SRC ebnf
LanguageTagExtended
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER
#+END_SRC

[[./ebnf-diagram/LanguageTagExtended.svg]]

The language script is an ISO 15924[fn:iso-15924] four letter code in title case.

#+BEGIN_SRC ebnf
LanguageTagScript
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER
#+END_SRC

[[./ebnf-diagram/LanguageTagScript.svg]]

The language region is either a two letter ISO 3166-1[fn:iso-3166-1] code or a three digit UN M49[fn:un-m49] code.

#+BEGIN_SRC ebnf
LanguageTagRegion
    ::= "-"
        ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )
#+END_SRC

[[./ebnf-diagram/LanguageTagRegion.svg]]

*** IRI References

An /IRI reference/ value in SDML is a value IRI value, either absolute or relative, between a Less-Than Sign ("<", =U+003C=)
character and a Greater-Than Sign (">", =U+003E=) character. IRI references are more permissive in the SDML grammar than
the Turtle[fn:iri] language.

#+BEGIN_SRC ebnf
Iri
    ::= "<"
        ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
        ">"
#+END_SRC

[[./ebnf-diagram/Iri.svg]]

*** Binary Strings

A /binary/ value in SDML is a compact list of bytes that allows for the encoding of values that may not be possible with
the other built-in types. The representation of a binary string is a sequence of bytes in hex pairs; the opening bracket
of the sequence has a leading Number Sign ("#", =U+0023=) character to differentiate from other sequence values. Note that
whitespace is entirely optional, but recommended to layout the hex values.

#+BEGIN_SRC ebnf
Binary
    ::= "#[" HexPair* "]"
#+END_SRC

[[./ebnf-diagram/Binary.svg]]

Here is an example showing a common layout with 16 bytes per row in two blocks of 8.

#+CAPTION: Binary Value Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = #[
    52  32  39  76  5a  43  42  43    65  57  55  67  51  33  4a  31
    5a  57  77  67  56  32  39  79    62  47  51  4b
  ]

end
#+END_SRC

*** Value Constructors

While the value =101= is defined to be an Integer literal, in the presence of sub-types how do you specify the type of a
literal? To accomplish this a /value constructor/ allows for specifying the precise type, or casting a value to a specific
type.

The syntax appears as a function call with a type reference followed by a valid /simple value/ surrounded by the Left
Parenthesis ("(", =U+0028=) and Right Parenthesis (")", =U+0029=) characters. The literal value MUST be valid for the
referenced type, or one of it's super-types.

#+BEGIN_SRC ebnf
ValueConstructor
    ::= IdentifierReference "(" SimpleValue ")"
#+END_SRC

[[./ebnf-diagram/ValueConstructor.svg]]

Here we assert that the value =1= is an unsigned rather than the default signed integer.

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: Example: Value Constructor
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = xsd:unsigned(1)

end
#+END_SRC

You can ignore the syntax of ~@ex:thing~ which is an annotation, see section [[sec:annotations]], used to ensure the syntax is
complete for all examples.

*** <<sec:mapping-values>>Mapping Values

A mapping value denotes a /functional relationship/ between the /domain/ (left-hand value) and /range/ (right-hand value).  

#+BEGIN_SRC ebnf
MappingValue
    ::= SimpleValue HasType Value
#+END_SRC

[[./ebnf-diagram/MappingValue.svg]]

Mapping values are most often used within lists to create dictionary-like structures.

#+NAME: lst:sdml-ex-mapping-list
#+CAPTION: Example: Mapping List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:dictionary = [
    "yes" -> 1
    "no" -> 2
    "maybe" -> 3
  ]

end
#+END_SRC
 
*** Sequence Values

As stated in section [[sec:modules-and-imports]], sequences in SDML start with the Left Square Bracket ("[", =U+005B=)
character and end with the Right Square Bracket ("]", =U+005D=) character with no separator character between members of
the list. Sequence values are, as one might expect, sequences of values and specifically of simple values. Sequence
value may also by heterogeneous and therefore contain elements of different types.

#+BEGIN_SRC js :noeval
SequenceOfValues
    ::= SequenceValueConstraint? "["
        ( SimpleValue | ValueConstructor | IdentifierReference )+
        "]"
SequenceValueConstraint
    ::= "{"
        ( SequenceOrdering? SequenceUniqueness? )
        "}"
#+END_SRC

[[./ebnf-diagram/SequenceOfValues.svg]]

[[./ebnf-diagram/SequenceValueConstraint.svg]]

#+NAME: lst:sdml-ex-sequence-value
#+CAPTION: Example: Sequence Value 
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = [ "yes" "no" "maybe" ]

end
#+END_SRC

#+NAME: lst:sdml-ex-sequence-value-constraint
#+CAPTION: Example: Sequence Value
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = {unique}[ "yes" "no" "maybe" ]

end
#+END_SRC

*** Defining Data Types

A datatype definition introduces a new simple data type by /restriction/ of some existing base type.

#+BEGIN_SRC ebnf
DataTypeDef
    ::= "datatype" Identifier
        TypeRestriction "opaque"? DataTypeBase AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/DataTypeDef.svg]]

#+BEGIN_SRC ebnf
TypeRestriction
    ::= "<-" | "←"
DataTypeBase
    ::= IdentifierReference | BuiltinSimpleType
#+END_SRC

[[./ebnf-diagram/DataTypeBase.svg]]

Listing [[lst:sdml-ex-datatype]] shows the /type restriction/ operator, =<-=, defining a new type named ~name~ as a restriction on
the existing XML Schema data type ~xsd:string~.

#+NAME: lst:sdml-ex-datatype
#+CAPTION: Example: New Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- string

end
#+END_SRC

While such a type is useful for conveying semantic meaning with types it doesn't provide any actual restriction on the
value space of the type. This is accomplished by using a subset of the /facets/ described in XML Schema part 2 to specify
constraints on the new type.


#+NAME: lst:sdml-ex-currency
#+CAPTION: Example: New Currency Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Currency <- decimal is
    @xsd:fractionDigits = 3
  end

  datatype Price <- Currency is
    @xsd:totalDigits = 7
  end

end
#+END_SRC

Also, in listing [[lst:sdml-ex-restricted-datatype]] we now see that the Name type
is a string whose length is between 5 and 25 characters only.

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: Example: New Datatype with Restrictions
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- string is
    @xsd:minLength = 5
    @xsd:maxLength = 25
  end

end
#+END_SRC

As we defined the new datatype ~Name~ as a kind of string it has all the properties (length, substring, etc.) of a string.
However, in some cases we may want the underlying type to be inaccessible to clients and so we mark the datatype as
/opaque/. The only operations that can be performed on an opaque type are equality and strict inequality.

#+NAME: lst:sdml-ex-opaque-datatype
#+CAPTION: Example: New Opaque Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- opaque string is
    @xsd:minLength = 5
    @xsd:maxLength = 25
  end

end
#+END_SRC

From OWL 2 Web Ontology Language Quick Reference Guide[fn:owlqr]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

** <<sec:sequence-types>>Sequence Types

When a structure member has a cardinality other than ~1..1~ it has to be represented by a /sequence type/. SDML bases it's
sequence types on /cardinality constraints/ rather than the direct specification of a collection type. This allows you to
specify the semantic intent of a member rather than picking a type and then worrying about the mapping of that to a
programming language types.

The current SDML cardinality constraints are:

- Ordering :: determines whether the sequence maintains the order of it's elements; one of ~ordered~ or ~unordered~ (default).
- Uniqueness :: determines whether the sequence allows duplicate elements or not; one of ~ordered~ or ~nonunique~ (default).

Table [[tbl:builtin-sequence-types]] shows how these constraints are combined to determine the corresponding SDML sequence
type. See also section [[seq:library-sequence-types]] which describes the standard library operations on sequence types.

#+NAME: tbl:builtin-sequence-types
#+CAPTION: Logical Sequence Types
| Ordering  | Uniqueness | /Logical Type/  | Example Specification |
|-----------+------------+---------------+-----------------------|
| ~unordered~ | ~nonunique~  | ~Bag~ (default) | ~{0..}~                 |
| ~ordered~   | ~nonunique~  | ~List~          | ~{ordered 0..}~         |
| n/a       | n/a        | ~Maybe~         | ~{0..1}~                |
| ~ordered~   | ~unique~     | ~OrderedSet~    | ~{ordered unique 0..}~  |
| ~unordered~ | ~unique~     | ~Set~           | ~{unique 0..}~          |

Note, any ordering or uniqueness constraint on the cardinality ~0..1~ is effectively ignored.

A /dictionary/ or /map/ structure can be described in SDML as a sequence of mapping values (see section [[sec:mapping-values]]).
Specifically the sequence type ~{unique 0..} (string -> string)~ is mapping from string values to other strings where each mapping
is unique, and for mapping types only the keys are considered in comparisons. The type ~{0..} (string -> string)~ does not
enforce uniqueness and thus is a /multi-map/.

** <<sec:annotations>>Annotations

Annotations allow for the assertion of facts attached to model elements that go beyond what is possible to describe in
the core syntax. Annotations are available in two forms, annotation properties, and constraints.

#+BEGIN_SRC ebnf
Annotation
    ::= AnnotationProperty | Constraint
#+END_SRC

[[./ebnf-diagram/Annotation.svg]]

A number of model elements described in the following sections have a body that may only contain annotations and so the
following common production is used.

#+BEGIN_SRC ebnf
AnnotationOnlyBody
    ::= "is" Annotation+ "end"
#+END_SRC

[[./ebnf-diagram/AnnotationOnlyBody.svg]]

*** Annotation Properties

Annotation Properties are an extension mechanism that interacts directly with the underlying RDF representation of the subject
model element. While these may look like Java /annotations/, Python /decorators/, or Rust /attributes/ it is more powerful in
that it can express arbitrary statements about the model element. An SDML annotation starts with the symbol "@" and then
has an identifier that resolves to an OWL annotation property (see section [[sec:define-rdf]] for the detailed rules), and a
value for the corresponding property range.

#+BEGIN_SRC ebnf
AnnotationProperty
    ::= "@" IdentiferReference "=" Value
#+END_SRC

[[./ebnf-diagram/AnnotationProperty.svg]]

The following example demonstrates a common annotation property attached to a module.

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: Example: Annotation Property
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import skos

  @skos:note = "This is an example annotation"

end
#+END_SRC

For descriptive annotation properties it is valuable to use the language specific string format so allow for
localization of labels and descriptions. The following example shows a simple label specified in multiple languages.

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: Example: Annotation Property List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import skos

  @skos:prefLabel = [
    "example"@en
    "exemple"@fr
    "例子"@zh-CH
  ]

end
#+END_SRC

A model element may have any number of annotation properties, especially the module itself which often includes
annotations for the domain itself.

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: Example: Annotated Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc skos xml ]

  @skos:prefLabel = "Example Module"@en
  @dc:description = "This is an example module, with two annotations."@en
  @dc:created = @xsd:date("2023-08-17 Thu")
  @dc:creator = <http://github.com/sdm-lang>
  @dc:license = <https://opensource.org/license/mit/>

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

*** Constraints

This section will only briefly introduce constraints as section [[sec:model-constraints]] provides a detailed description.
The first example, in listing [[lst:sdml-ex-constrained-module]], provides an informal constraint in that it is simply a
string which is useful to readers but cannot be verified.

#+NAME: lst:sdml-ex-constrained-module
#+CAPTION: Example: Informal Constraint on Module
#+BEGIN_SRC sdml :exports code :noeval
module rental is

  assert name_form = "All definition names MUST start with 'Rental'"

end
#+END_SRC

While informal constraints are not validated in any way, given the ambiguities of human language a controlled language
is a useful alternative.

A formal constraint on the other hand may be verified, but takes more work to structure correctly. The example in
listing [[lst:sdml-ex-formal-constrained-module]] example above by methodically checking every definition and any members
therein.

#+NAME: lst:sdml-ex-formal-constrained-module
#+CAPTION: Example: Formal Constraint on Module
#+BEGIN_SRC sdml :exports code :noeval
module rental is

  assert name_form is
    forall d in definitions(self), d.name.has_prefix("Rental")
  end

  assert name_form_alternate is
    ∀ d ∈ definitions(self) has_prefix(name(d) "Rental")
  end

end
#+END_SRC

*** <<sec:define-rdf>> Defining RDF Classes and Properties

In general only properties that have an RDF type of =owl:AnnotationProperty=, or are sub-properties of such a property,
may appear as annotations. This maintains the assertion that they are annotations of their subject and allows the use of
a range of pre-defined annotation properties from RDF, RDF Schema, OWL, and the Dublin Core Metadata Initiative
(DCMI)[fn:dcmi].

For example the annotation property =rdfs:comment= is defined in the following manner allowing it's use on any resource
and with a value that may be any literal.

#+NAME: lst:rdfs-comment
#+CAPTION: The definition of rdfs:comment
#+BEGIN_SRC ttl
rdfs:comment rdf:type rdf:Property, owl:AnnotationProperty ;
	rdfs:isDefinedBy <http://www.w3.org/2000/01/rdf-schema#> ;
	rdfs:label "comment" ;
	rdfs:comment "A description of the subject resource." ;
	rdfs:domain rdfs:Resource ;
	rdfs:range rdfs:Literal .
#+END_SRC

To allow the standard library to define SDML equivalents of such properties it is necessary to provide a mechanism to
use non-annotation properties such as =rdf:type=, =rdfs:domain=, and =rdfs:range= as demonstrated in the example above. To
allow this, if a model element has the property =rdf:type= then the transformation from that element to RDF *does not* use
any of the transformations described here but an explicit mapping from *only* the provided properties.

Rewriting the RDF from listing [[lst:rdfs-comment]] into SDML results in the definition in listing [[lst:rdfs-comment-in-sdml]].

#+NAME: lst:rdfs-comment-in-sdml
#+CAPTION: The SDML definition of rdfs:comment
#+BEGIN_SRC sdml :exports code :noeval
module rdf_schema base <http://www.w3.org/2000/01/rdf-schema#> is

  import [ rdf owl ]

  rdf structure Resource is
    ;; rdf:type -- rdf:Class is automatically implied
    ;; rdfs:label -- structure name is automatically implied
    ;; @isDefinedBy -- module base URL is automatically implied
    @comment = "The class resource, everything."
  end

  rdf property comment is
    ;; rdf:type -- rdf:Property is automatically implied
    ;; rdfs:label -- property name is automatically implied
    ;; @isDefinedBy -- module base URL is automatically implied
    @rdf:type = owl:AnnotationProperty
    @comment = "A description of the subject resource."
    @domain = Resource
    @range = Literal
  end

end
#+END_SRC

The following are commonly used RDF and OWL definition properties.

| Property               | Applies To | Type           | Comments |
|------------------------+------------+----------------+----------|
| =rdf:type=               | Either     | Type Reference |          |
| =rdfs:domain=            | Property   | Type Reference |          |
| =rdfs:range=             | Property   | Type Reference |          |
| =rdfs:subClassOf=        | Structure  | Type Reference |          |
| =rdfs:subPropertyOf=     | Property   | Type Reference |          |
| =owl:equivalentClass=    | Structure  | Type Reference |          |
| =owl:equivalentProperty= | Property   | Type Reference |          |
| =owl:inverseOf=          | Property   | Type Reference |          |
| =owl:disjointWith=       | Structure  | Type Reference |          |
|                        |            |                |          |

Commonly used annotation super-types

- =owl:AnnotationProperty=
- =owl:FunctionalProperty=
- =owl:InverseFunctionalProperty=
- =owl:SymmetricProperty=
- =owl:TransitiveProperty=

** <<sec:structured-types>>Structured Types

Structured types fall into two primary categories, /Product/ types and /Sum/ types. Product types have named and typed
/Members/ and in SDML these are structures, entities and events. Sum types on the other hand have /Variants/ and in SDML
these are enumerations and disjoint unions. In the surface syntax product type bodies are introduced by the keyword ~is~
whereas sum type bodies are introduced by the keyword ~of~.

*** Structures

A structure is a product type that is composed of named and typed members. A structure is therefore akin to a record
type, a table in data modeling, or a class in object modeling.

#+BEGIN_SRC ebnf
StructureDef
    ::= "structure" Identifier StructuredBody?
#+END_SRC

[[./ebnf-diagram/StructureDef.svg]]

As only the keyword ~structure~ and the identifier are required, the listing [[lst:sdml-ex-empty-structure]] is therefore a
valid model.

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: Example: Empty Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length

end
#+END_SRC

The structure ~Length~ in listing [[lst:sdml-ex-empty-structure]] is /valid/ but considered incomplete. Adding a body to the
structure, between ~is~ and ~end~, makes it complete even if it has no actual members. In listing
[[lst:sdml-ex-annotated-structure]] the structure Length is now complete.


#+BEGIN_SRC ebnf
StructuredBody
    ::= "is" Annotation* Member+ "end"
#+END_SRC

[[./ebnf-diagram/StructuredBody.svg]]

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: Example: Annotated Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length is
    @skos:prefLabel = "Length"@en
  end

end
#+END_SRC

Listing [[lst:sdml-ex-structure-members]] adds the members ~value~ and ~unit~ and their corresponding types.

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: Example: Structure Members
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end

end
#+END_SRC

*** Entities

#+BEGIN_SRC ebnf
EntityDef
    ::= "entity" Identifier EntityBody?

#+END_SRC

[[./ebnf-diagram/EntityDef.svg]]

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: Example: Empty Entity
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person

end
#+END_SRC

The entity ~Person~ in listing [[lst:sdml-ex-empty-entity]] is /valid/ but /incomplete/.

#+BEGIN_SRC ebnf
EntityBody
    ::= "is"
        Annotation* EntityIdentity Member*
        "end"
#+END_SRC

[[./ebnf-diagram/EntityBody.svg]]

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: Example: Entity with Identifying Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person is
    identity id -> PersonId
  end

end
#+END_SRC

The ~identity~ member is a required part of the entity definition, it not only tells us what type represents the unique
identifier for this entity but is also used in event sources (see section [[sec:entity-events]]).

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: Entity with Reference Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person is
  
    identity id -> PersonId

    emergency_contact (emergency_contact_for) -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  
  end
end
#+END_SRC

*** <<sec:entity-events>>Entity Events

Entity Events, or simply Events, model notifications generated by an entity most often representing a state change in the entity.
As such a ~source~ reference denotes the entity which generates this event. Any expansion of the event structure *must* include the
identifiers of the source entity.

#+BEGIN_SRC ebnf
EventDef
    ::= "event" Identifier
        "source" IdentifierReference
        StructuredBody?
#+END_SRC

[[./ebnf-diagram/EventDef.svg]]

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: Example: Empty Event
#+BEGIN_SRC sdml :exports code :noeval
module example is

  event PersonNameChanged source Person

end
#+END_SRC

With the expansion of the ~source~ entity the event definition above is logically equivalent to the following structure.

#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure PersonNameChanged is
    id -> PersonId is
      @sdml:identifies = Person
    end
  end

end
#+END_SRC

As we have seen before, the event ~PersonNameChanged~ in listing [[lst:sdml-ex-empty-event]] is valid but incomplete.

The following is a valid /and/ complete event definition with two structure members.

#+NAME: lst:sdml-ex-event
#+CAPTION: Example: Event
#+BEGIN_SRC sdml :exports code :noeval
module example is

  event PersonNameChanged source Person is
    fromValue -> Name
    toValue -> Name
  end

end
#+END_SRC

*** Enumerations

An enumeration defines a set of unique constant values. The representation of these values is not defined by SDML,
allowing users of the model to choose a scheme that matches their need.

Note that the keyword =of= and not =is= starts an enumeration body.

#+BEGIN_SRC ebnf
EnumDef
    ::= "enum" Identifier EnumBody?
#+END_SRC

[[./ebnf-diagram/EnumDef.svg]]

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: Example: Empty Enum
#+BEGIN_SRC sdml :exports code :noeval
module example is

  enum DistanceUnit

end
#+END_SRC

The enumeration ~DistanceUnit~ in [[lst:sdml-ex-empty-enum]] is valid but incomplete. Completion of the enumeration requires
the addition of a body with enumeration variants.

#+BEGIN_SRC ebnf
EnumBody
    ::= "of" Annotation* ValueVariant+ "end"
#+END_SRC

[[./ebnf-diagram/EnumBody.svg]]

#+BEGIN_SRC ebnf
ValueVariant
    ::= Identifier AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/ValueVariant.svg]]

The following demonstrates a valid /and/ complete enumeration.

#+NAME: lst:sdml-ex-enum
#+CAPTION: Example: Enum With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is

  enum DistanceUnit of
    Meter
    Foot
  end

end
#+END_SRC

While SDML only guarantees that a /unique value/ is assigned to each variant within an enumeration it does not say what
the type of this value is, or how it is represented. In effect the datatype of a variant's value is /opaque/ and therefore
supports only equality tests.

Where it is useful to assign specific values to variants this can be accomplished with a pair of annotations,
~owl:equivalentClass~ and ~rdf:value~. The first identifies a specific datatype to be used to represent the
enumeration. Listing [[lst:sdml-ex-typed-enum]] shows our previous enum declaration with a representation type of
~sdml:integer~, however the specific values for each variant are still assigned by the model. Only types derived from
the types ~boolean~, ~decimal~, ~integer~, ~iri~, ~string~ or ~unsigned~ are allowed as enum representation types.

#+NAME: lst:sdml-ex-typed-enum
#+CAPTION: Example: Enum With Equivalent Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import owl

  enum DistanceUnit of
    @owl:equivalentClass = sdml:integer
  
    Meter
    Foot
  end

end
#+END_SRC

It is possible for the model author to set specific values for each variant, *if* they have provided an equivalent class
annotation to the declaration for the enum itself. To accomplish this, the author adds an ~rdf:value~ attribute property
to each variant with a unique value with the datatype specified. 

#+NAME: lst:sdml-ex-valued-enum
#+CAPTION: Example: Enum With Variant Values
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ owl rdf ]

  enum DistanceUnit of
    @owl:equivalentClass = sdml:integer

    Meter is
      @rdf:value = 1
    end

    Foot is
      @rdf:value = 2
    end

  end

end
#+END_SRC

Specifically, to assign values to enumerations the following constraints must be met:

1. The value of an ~owl:equivalentClass~ annotation on an enum declaration *must* be one of the supported datatypes, or a
   type derived from one.
1. If more than one ~owl:equivalentClass~ annotation is present they *must* have distinct base data types. See listing
   [[lst:sdml-ex-multi-valued-enum]].
1. The presence of an ~rdf:value~ annotation on a variant *requires* the presence of a corresponding ~owl:equivalentClass~
   annotation on the enclosing enum declaration.
1. If *no* ~rdf:value~ is specified for a variant the model will assign a unique value.
   1. It is *recommended* that you either specify *all* values, or leave all to the model to assign.
1. Each variant's ~rdf:value~ *must* be unique.
1. Where the literal syntax of a type overlaps, specifically for ~signed~ and ~unsigned~ integers, type constructors may be
   used to disambiguate the value type. See listing [[lst:sdml-ex-conflicting-valued-enum]].
   
#+NAME: lst:sdml-ex-multi-valued-enum
#+CAPTION: Example: Enum With Multiple Variant Values
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ owl rdf ]

  enum DistanceUnit of
    @owl:equivalentClass = sdml:integer
    @owl:equivalentClass = sdml:string

    Meter is
      @rdf:value = 1
    end

    Foot is
      @rdf:value = 2
    
    end

  end

end
#+END_SRC
   
#+NAME: lst:sdml-ex-conflicting-valued-enum
#+CAPTION: Example: Enum With Conflicting Variant Values
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ owl rdf ]

  enum DistanceUnit of
    @owl:equivalentClass = sdml:integer
    @owl:equivalentClass = sdml:unsigned

    Meter is
      @rdf:value = xsd:integer(1)
    end

    Foot is
      @rdf:value = xsd:integer(2)
    end

  end

end
#+END_SRC

*** Disjoint Unions

A disjoint, or discriminated, union is a mechanism to allow for a selection of disjoint types to be treated as a single
type. As such the /variants/ of the union are simply type references, although they do allow annotations. Note also that
the keyword =of= and not =is= starts a union body.

#+BEGIN_SRC ebnf
UnionDef
    ::= "union" Identifier UnionBody?
#+END_SRC

[[./ebnf-diagram/UnionDef.svg]]

#+NAME: lst:sdml-ex-empty-union
#+CAPTION: Example: Empty Union
#+BEGIN_SRC sdml :exports code :noeval
module example is

  union VehicleClass

end
#+END_SRC

The union ~VehicleClass~ in [[lst:sdml-ex-empty-union]] is valid but incomplete. Completion of the union requires the addition
of a body with type variants.

#+BEGIN_SRC ebnf
UnionBody
    ::= "of"
        Annotation* TypeVariant+
        "end"
#+END_SRC

[[./ebnf-diagram/UnionBody.svg]]

#+BEGIN_SRC ebnf
TypeVariant
    ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/TypeVariant.svg]]

#+BEGIN_SRC ebnf
TypeVariantRename
    ::= "as" Identifier
#+END_SRC

[[./ebnf-diagram/TypeVariantRename.svg]]

The following is a valid /and/ complete example with three type variants and one that is renamed from =Van= to =LittleTruck=.

#+NAME: lst:sdml-ex-union
#+CAPTION: Example: Union With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is

  union VehicleClass of
    Car
    Truck
    Van as LittleTruck
  end

end
#+END_SRC

** <<sec:members>>Structure Members

Product type members should be familiar to anyone exposed to either programming languages or data definition languages
such as SQL. A name is associated with a type, an optional inverse name, and may have annotations.

#+BEGIN_SRC ebnf
Member
    ::= Identifier
        ( PropertyReference | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/Member.svg]]

#+NAME: lst:sdml-ex-min-member
#+CAPTION: Example: Minimal Structure Member
#+BEGIN_SRC sdml :exports code :noeval
module accounts is

  structure Account is
    name -> string
  end

end
#+END_SRC

*** Member Types

To allow for the capture of member names before the elaboration of all types the language allows for the
target type to be replaced with the keyword ~unknown~. This marks the member, and by extension it's owning type, as
/incomplete/. Note the grammar allows ASCII and Unicode representations of the /has type/ operator.

#+BEGIN_SRC ebnf
TypeExpression 
    ::= HasType TypeReference
TypeExpressionTo
    ::= HasType Cardinality? "features"? TypeReference
HasType
    ::= "->" | "→"
TypeReference
    ::=  UnknownType | IdentifierReference | BuiltinSimpleType | MappingType
UnknownType
    ::= "unknown"
#+END_SRC

[[./ebnf-diagram/TypeExpression.svg]]

[[./ebnf-diagram/TypeExpressionTo.svg]]

[[./ebnf-diagram/TypeReference.svg]]

A mapping type denotes a /functional relationship/ between the /domain/ (left-hand type) and /range/ (right-hand type).

#+BEGIN_SRC ebnf
MappingType
    ::= "(" TypeReference HasType TypeReference ")"
#+END_SRC

[[./ebnf-diagram/MappingType.svg]]

The syntax for mapping values was previously described in section [[sec:mapping-values]].

*** Member Cardinality

The *cardinality* of a member is specified as a range operation with a minimum and maximum number of occurrences
specified. Additionally cardinality constraints determine the ordering and uniqueness of the collection of member values
in a sequence type (see section [[sec:sequence-types]]).

- The form ~{1..3}~ specifies a cardinality of 1 to 3 inclusive, or $[1,3]$ in interval notation.
- The form ~{1..}~ specifies a minimum of 1 occurrences an unbounded maximum, or $[1,\infty]$ in interval notation.
- The form ~{1}~ specifies that 1 is both the minimum and maximum value, or $[1,1]$ in interval notation, commonly termed
  a /degenerate/ interval.

#+BEGIN_SRC ebnf
Cardinality
    ::= "{" SequenceOrdering? SequenceUniqueness? CardinalityInner "}"
CardinalityInner
    ::= Unsigned CardinalityRange?
CardinalityRange
    ::= ".." Unsigned?
#+END_SRC

[[./ebnf-diagram/Cardinality.svg]]

[[./ebnf-diagram/CardinalityInner.svg]]

[[./ebnf-diagram/CardinalityRange.svg]]

#+BEGIN_SRC ebnf
SequenceOrdering
    ::= ( "ordered" | "unordered" )
SequenceUniqueness
    ::= ( "unique" | "nonunique" )
#+END_SRC

[[./ebnf-diagram/SequenceOrdering.svg]]

[[./ebnf-diagram/SequenceUniqueness.svg]]

*** Inverse Names

#+BEGIN_SRC ebnf
InverseName
    ::= "(" Identifier ")"
#+END_SRC

[[./ebnf-diagram/InverseName.svg]]

#+NAME: lst:sdml-ex-inverse-name
#+CAPTION: Example: Inverse Name
#+BEGIN_SRC sdml :exports code :noeval
module accounts is

  import users

  entity Account is
    identity id -> AccountId
    owner (owned_account) -> users:User
  end

end
#+END_SRC

*** Identity Members

#+BEGIN_SRC ebnf
EntityIdentity
    ::= "identity" Identifier
        ( PropertyMember | ( TypeExpression AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/EntityIdentity.svg]]

#+NAME: lst:sdml-ex-entity-identity
#+CAPTION: Example: Entity Identity
#+BEGIN_SRC sdml :exports code :noeval
module accounts is

  datatype AccountId <- opaque string

  entity Account is
    identity id -> AccountId
    name -> string
  end

end
#+END_SRC
*** Property Reference

#+BEGIN_SRC ebnf
PropertyReference
    ::= "in" IdentifierReference
#+END_SRC

[[./ebnf-diagram/PropertyReference.svg]]

In the following example ([[lst:sdml-ex-property-reference]]) we see two members, ~default~ and ~name~. The former is actually a reference to a property role,
specifically the role ~default~ within the property definition ~AccountId~ in module ~account~. The latter is a /defined/ member
with the name ~name~ and the type ~string~ and default cardinality.

#+NAME: lst:sdml-ex-property-reference
#+CAPTION: Example: Using a Property Reference
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import accounts

  structure Record is
    default in accounts:AccountId
    name -> string
  end

end
#+END_SRC

*** Feature Members

...

#+NAME: lst:sdml-ex-entity-features
#+CAPTION: Example: Declaring Feature Member
#+BEGIN_SRC sdml :exports code :noeval
module rentals is

  import vehicles

  entity Rental is
    identity id -> unknown
    options -> features vehicles:Options
  end

end
#+END_SRC

#+NAME: lst:sdml-ex-entity-features-expanded
#+CAPTION: Example: Feature Member Constraint
#+BEGIN_SRC sdml :exports code :noeval
module rentals is

  import vehicles

  entity Rental is
    identity id -> unknown
    options -> vehicles:Options is
      assert is_exclusive_feature is
        forall self (
          self.type_of_type = sdml:Union and
          is_unique({ t | forall t in X, type_of(t) })
        )
      end
    end
  end

end
#+END_SRC

** <<sec:properties>>Property Definitions

SDML provides for a data dictionary, or element-first, style of model capture where key properties of the domain are
defined and annotated in a stand-alone form. These are often key identifiers and other shared properties 

#+BEGIN_SRC ebnf
PropertyDef
    ::= "property" Identifier PropertyBody?
#+END_SRC

[[./ebnf-diagram/PropertyDef.svg]]

#+NAME: lst:sdml-ex-empty-property
#+CAPTION: Example: Empty Property Definition
#+BEGIN_SRC sdml :exports code :noeval
module example is

  property account_id

end
#+END_SRC

The property ~account_id~ in [[lst:sdml-ex-empty-property]] is valid but incomplete. Completion of the property requires the
addition of a body with roles defined.

#+BEGIN_SRC ebnf
PropertyBody
    ::= "is" Annotation* ( IdentityRole | MemberRole )+ "end"
#+END_SRC

[[./ebnf-diagram/PropertyBody.svg]]

Note that the syntax of role definitions is a subset of the syntax for members (see section [[sec:members]]). In each case
the choice between a property reference and a member definition is removed and only the definition part remains.

#+BEGIN_SRC ebnf
IdentityRole
    ::= "identity" Identifier TypeExpression AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/IdentityRole.svg]]

#+BEGIN_SRC ebnf
MemberRole
    ::= Identifier InverseName? TypeExpressionTo AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/MemberRole.svg]]

The following is a valid /and/ complete example.

#+NAME: lst:sdml-ex-property-role
#+CAPTION: Example: Property Definition with Roles
#+BEGIN_SRC sdml :exports code :noeval
module account is

  datatype Accountid <- unsigned

  property accountId is

    identity identifier -> {1} AccountId is
      @skos:definition =
        "The identifier that denotes that this entity has a one-to-one relationship with a customer account."@en
    end

    account -> {1} Account is
      @skos:definition =
        "Refers to a customer account entity."@en
    end

    account_identifier -> AccountId is
      @skos:definition =
        "Refers to an entity that has a one-to-one relationship with a customer account."@en
    end

  end

  entity Account

end
#+END_SRC


# ----- Footnotes

[fn:dcmi] [[https://www.dublincore.org/specifications/dublin-core/dcmi-terms/][DublinCoreDCMI Metadata Terms]], DublinCore
[fn:ucgc] [[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]], Unicode.org
[fn:iri] RDF 1.1 Turtle – Terse RDF Triple Language, §[[https://www.w3.org/TR/turtle/#sec-iri-references][6.3 IRI References]], W3C
[fn:sparql] [[https://www.w3.org/TR/sparql11-overview/][SPARQL 1.1 Overview]], W3C
[fn:owlqr] [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide
(Second Edition)]], W3C
[fn:iso-639-1] [[https://www.iso.org/standard/22109.html][Codes for the representation of names of languages — Part 1: Alpha-2 code]] (ISO 639-1:2002), ISO
[fn:iso-639-2] [[https://www.iso.org/standard/4767.html][Codes for the representation of names of languages — Part 2: Alpha-3 code]] (ISO 639-2:1998), ISO
[fn:iso-15924] [[https://www.iso.org/standard/81905.html][Information and documentation — Codes for the representation of names of scripts]] (ISO 15924:2022), ISO
[fn:iso-3166-1] [[https://www.iso.org/standard/72482.html][Codes for the representation of names of countries and their subdivisions — Part 1: Country code]] (ISO 3166-1:2020), ISO
[fn:un-m49] [[https://unstats.un.org/unsd/methodology/m49/][Standard Country or Area Codes for Statistical Use]] (M49), UN
