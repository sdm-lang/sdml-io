#+TITLE: Simple Domain Modeling Language
#+SUBTITLE: Language Primer
#+AUTHOR: Simon Johnston
#+EMAIL: johnstonskj@gmail.com
#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="sdml-io.css"/>
#+LATEX_HEADER: \usepackage{makeidx}
#+LATEX_HEADER: \makeindex
#+OPTIONS: toc:3 ^:{}


#+BEGIN_SRC emacs-lisp :exports none
(require 'ob-dot) ;; builtin
(require 'ob-sdml)
#+END_SRC

#+NAME: img:sdml-logo
#+ATTR_HTML: :width 75% :height 75%
[[./logo/svg/square-dark.svg]]

This short primer introduces the Simple Domain Modeling Language (SDML) and how you can apply it to model your business
domain. This is not a replacement for the main SDML [[https://sdml.io][documentation]] but instead a quick tour of the language, it's
features and application. This introduction will focus only on the SDML /surface syntax/, the textual representation that
most people will interact with directly, whereas the main documentation also covers the semantics of the language and
mappings between SDML and other key models. The primer also covers the core concepts that almost everyone will need to
know, with pointers to the more advanced topics in the main documentation (notes marked with ðŸŽ›).

So, let's start...

* Why do I want a Domain Model?
:PROPERTIES:
:CUSTOM_ID: why-domain-model
:END:

Modeling in software development has had a difficult history, in some technical domains it is considered an essential
tool. However, in many others, and especially with the emergence of agile development practices, it is considered an
unnecessary overhead. George Box (statistician) famously wrote, "/All models are wrong, some are useful./", and later
expanded it to

#+BEGIN_QUOTE
All models are approximations. Assumptions, whether implied or clearly stated, are never exactly true. All models are
wrong, but some models are useful. So the question you need to ask is not "Is the model true?" (it never is) but "Is the
model good enough for this particular application?" --- George E. P. Box, 1976.
#+END_QUOTE

So why would we build a domain model? Well, from the introduction to the guidance topic /Domain Modeling/ in the Scaled
Agile Framework we get the following.

#+BEGIN_QUOTE
Domain modeling is one of the key models used in software engineering: *if you only model one thing in Agile, model the
domain*. A relatively small domain-modeling effort is a great tool for controlling the complexity of the system under
development. It may help in resolving countless ambiguities in both the requirements and the design intent. Domain
modeling simply reflects our understanding of real-world *entities* and their *relationships* and *responsibilities* that
cover the problem domain.
#+END_QUOTE

It is the essential characteristic of the domain model that it *must* reflect real-world entities, the tangible and
intangible artifacts that are the common vocabulary of the domain. For example, in a Hotel domain model we may introduce
Hotel, Room, Customer, and Booking as entities whereas a car rental domain model would have Location, Vehicle, Customer,
and Booking. These entities should not be abstracted more than necessary, while the term /Location/ in the rental model
could be considered as a generic form for /Hotel/ it is not, they are not the same and the choice of Location was not for
genericity or abstraction but because that is the term that the rental car industry uses.

As such, a domain model is an essential communication tool, not only between the business and technology sides of an
organization but also between the business and it's customers and partners. Some industry standards for example use a
common domain model to help facilitate the understanding of the standards themselves and how they apply between parties. 

** Where do I start?
:PROPERTIES:
:CUSTOM_ID: where-to-start
:END:

One answer to that question is whether existing domain models already exist for your industry, often from standards
organizations. If not then you would want to get a group of subject-matter experts (SMEs) together to talk through the
key components of your business and how they relate to each other. You want to identify first those real-world entities
that comprise the core of the business, and start with the ones your customers would be able to articulate -- only
because that simple test helps to identify the truly essential elements.

Include stakeholders across your business /and/ with different roles and perspectives. This is not a time to be parochial,
to codify existing organizational structures or silos. Ask yourself, "/If we were to fundamentally reorganize our
internal structure, would these entities have to change?/" and if the answer is /yes/ you almost certainly have something
wrong. The danger is that your modeling effort falls foul of Conway's law:

#+BEGIN_QUOTE
Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the
organization's communication structure. --- Melvin E. Conway, 1967.
#+END_QUOTE

Another good place to start is to ask participants to describe the business in only 1 or 2 sentences. In the following
we have highlighted obvious candidate entities in bold, and phrases that may hide entities in italics.

- Retail: *Customers* go to a *store* to *purchase* *items*, they may have a specific item in mind or expect to find /choices
  they can choose between/. Depending on the /kind of item/ this choice may be /variations (in size or color for example)/ of
  the same item or the same kind of item from /different manufacturers/.
- Hotel: A *customer* *books* a *room* according to their choice of /size, bed type, or other criteria/, for /specific dates/ at a
  particular *property*. A customer may make /certain kinds/ of *purchase* against their room which are then added to the
  final *bill* on /completion of their stay/.
- Long-Haul Logistics: The business comprises /matching/ available transportation *capacity* on one or more *routes* to
  /deliver/ a *customer*'s load from /source to destination/ within some /time constraint/. A load may be one or more *standard
  palettes*, or one or more *standard containers*. This results in one or more *delivery contracts*.

The next step may be to ask questions such as "/does the (candidate) entity *X* have a natural and unique identifier?/",
"/what properties does the (candidate) entity *X* have?/", or "/if we don't think *X* is an entity, what is it?/". All of these
help to elaborate an initial framework that you can hang more detail on as you spend more time with more stakeholders.
Whether you capture this in a structured form such as SDML, a graphical form such as a Visio diagram or data model
diagram, or even natural language notes, you now have a domain model.

The first of these questions is actually the most important as we can define an entity according to the following rules.

An Entity is:

1. the name of a real-world concept,
2. usually being a noun in the language used to describe the domain,
3. that has an independent lifecycle (is not dependent on the lifecycle of another),
4. and has a natural and unique identifier.

* What is SDML?
:PROPERTIES:
:CUSTOM_ID: what-is-sdml
:END:

SDML is a textual language that allows you to describe a domain model in a /relatively/ simple structured manner. We say
relatively because the language allows you to build models iteratively, capturing the essentials first and elaborating
on them over time. It is common for domain models to be the output of workshop sessions and so the ability to capture a
valid model in real-time even if it lacks detail is a useful feature. With this in mind we will elaborate on the module
/definition/ in listing [[src:retail-module]] during this primer.

#+NAME: src:retail-module
#+CAPTION: An empty module
#+BEGIN_SRC sdml -n :exports code :noeval
module retail is end
#+END_SRC

This is, obviously, not a very informative definition of the retail domain; however, it is a valid model and a good
enough place to start. But, as you've been tasked with being the scribe at a workshop outlining the domain model for a
retail business you're on track so far. We will see more features in the following sections.

One question you may have, why a textual language, why not a fancy graphical one, or an even fancier web-based graphical
one? The reasons are purely pragmatic; *1.* simpler to build, *2.* now you have a persistent format, *3.* easier to agree
details, *4.* not everyone is a visual thinker, and *5.* it's usually easier to define a visual representation of textual
form than a textual representation of a visual one. One (and not necessarily the most urgent) of the problems that has
hampered the adoption of the UML language for example is that there is no standard representation and so all tools have
to write import/export capabilities to share models leading to errors or inconsistencies. SDML has a native
representation, the surface syntax (it actually has two, more on that in a moment) and all tool builders can rely on
being able to read and write that syntax.

#+BEGIN_ADVNOTE
What is the other representation? The textual language, shown in listing [[src:retail-module]] has a direct mapping to, and
can be considered an alternate syntax for, a particular [[https://www.w3.org/TR/rdf12-concepts][RDF]]/[[https://www.w3.org/OWL/][OWL]] ontology *[need link]*. This means that the /semantics/ of
SDML are then described by the OWL ontology, then OWL, and then RDF. Understanding this is not necessary to using or
understanding the SDML syntax.
#+END_ADVNOTE

The SDML /project/, which is more than just the language definition, provides editor integration for authoring and tools
for drawing and documentation. It also produces this primer and the main documentation.

** What it isn't

- SDML is not, as we said above, a graphical language. It relies on a defined mapping to the UML language that allows
  the core elements of the textual language to be represented visually in UML.
- SDML is not a product, it's freely available and open source.
- SDML is not a standard, there's no committee managing changes. Feel free to file an enhancement request, or if you
  have a change a pull request, because...
- SDML is not done, we expect evolution as we see interesting opportunities to help you, and you see things we missed.

* What can I do with it?
:PROPERTIES:
:CUSTOM_ID: what-can-it-do
:END:

The value of a domain model is in being able to describe the domain in an unambiguous way, so that it can become a
shared vocabulary which in turn requires some rigor. One of the goals of SDML is to allow you to apply rigor as needed
and elaborate the model over time. Some modeling tools, techniques, and processes, seem to require you to front-load the
details and it can be hard to get past the /blank page/ problem as it feels like you need to do so much just to start.

This section will show this elaboration process in action as we build the models for our example domains: Retail,
Hospitality, and Logistics. 

** Capture Entities
:PROPERTIES:
:CUSTOM_ID: capture-entities
:END:

Let's add the entities from the previous natural language description to our module. In each of the following sections
we will repeat the descriptive text and follow it with an initial model. Note that all we need to do at this stage is
list the entities we have identified so far using the rather obvious keyword ~entity~. 

*** Retail Example

#+BEGIN_INDENTED
*Customers* go to a *store* to *purchase* *items*, they may have a specific item in mind or expect to find /choices they can
choose between/. Depending on the /kind of item/ this choice may be /variations (in size or color for example)/ of the same
item or the same kind of item from /different manufacturers/.
#+END_INDENTED

When we look at the italic text above we note the possible entities Kind, Variation, Size, Color, and Manufacturer.
However, as we talk them through with the stakeholders we feel that they do not meet the criteria outlined in the
section [[#where-to-start][Where do I start?]], except ~Manufacturer~.

#+NAME: src:initial-retail-entities
#+CAPTION: Initial Retail Entities
#+BEGIN_SRC sdml -n :exports code :noeval
module retail is

  entity Customer

  entity Store

  entity Purchase

  entity Item

  entity Manufacturer

end
#+END_SRC

Note that, depending on how you state the initial part of the description above you may end up with a different name for
the entity ~Purchase~; "A store sells items to customers" for example will result in essentially the same entity but with
the name ~Sale~ only because the subject of the sentence has changed. Beware of this, try and always pick a subject to use
for all descriptions to avoid models that include both purchase and sale! In general, we recommend that you pick the
customer as the primary subject as it means you end up with fewer internal names or jargon names for things.

*** Hospitality Example

#+BEGIN_INDENTED
A *customer* *books* a *room* according to their choice of /size, bed type, or other criteria/, for /specific dates/ at a
particular *property*. A customer may make /certain kinds/ of *purchases* against their room which are then added to the
final *bill* on /completion of their stay/.
#+END_INDENTED

The only additional entity beyond the set already identified in bold is possibly ~Stay~, which at first looks a lot like
~Booking~ in that it has a start and end date and references a ~Customer~ and ~Property~. However, a booking reference the
/type of room/ where as the stay references the actual room, and the start and end dates may not be the same if the
customer left early for example.

In listing [[src:initial-hospitality-entities]] we will fill in some details, just to see how it's done. Specifically note
the use of the arrow operator ~->~ or ~â†’~ that denotes the type (right-hand side) of a member (left-hand side). Also, if you
remember that a part of the definition of an entity is that it has strong identity, so as we are adding details to
entities we *must* provide an ~identity~ member.

#+NAME: src:initial-hospitality-entities
#+CAPTION: Initial Hospitality Entities
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality is

  import xsd

  entity Customer

  entity Booking is
    identity booking_code -> string
    customer -> Customer
    property -> Property
    room_type -> unknown ;; don't know what this is yet.
    start_date -> xsd:date
    end_date -> xsd:date
    number_of_adults -> integer
    number_of_children -> integer
  end

  entity Room

  entity Property

  entity Purchase

  entity Bill is
    identity transaction_id -> unknown
    for_stay -> Stay
    charges -> {0..} Purchase
  end

  entity Stay is
    identity id -> unknown
    from_booking -> {0..1} Booking
  end

end
#+END_SRC

The following are useful pointers to features of the entity definition.

1. Lines 9-10: the members named ~customer~ and ~property~ reference other entities in the same module /even though/ neither of those
   entities are complete.
2. Line 11: the member named ~room_type~ has the type ~*unknown*~ which is an explicit signal that this model is incomplete as the
   type has not yet been decided.
3. Line 11: the semi-colon introduces a line comment, so we added a little note to ourselves about the unknown type for this
   member. The use of two semi-colons is a style preference as it makes the comment easier to find.
4. Lines 8,11-15: the type names ~string~ and ~integer~ (and ~unknown~) are builtin, the type ~xsd:date~ is not, it has been imported from
   another module named ~xsd~. The name ~xsd:date~ is a /qualified name/ which uses the colon character to combine module and
   definition name.
5. Line 27: the member named in ~charges~ in ~Bill~ is a /sequence type/, which means it can have a varying number of values. The
   specification for upper and lower bounds on a sequence type are it's cardinality, the lack of a upper bound means
   that the range is /unbounded/. The default cardinality being ~1~.
6. Line 32: the member named ~from_booking~ in ~Stay~ is another sequence type, although with the cardinality of ~0..1~ may be seen as
   /optional/.

The builtin datatypes in SDML are derived from those in the XML Schema, Part 2 specification, the same datatypes used in
RDF. The major datatypes are listed in table [[tbl:datatype-comparisons]] and compared to corresponding datatypes in SQL,
Java and Rust. SQL's Data Definition Language (DDL) is a useful comparison given that it may be familiar to less
technical stakeholders.

#+NAME: tbl:datatype-comparisons
#+CAPTION: Datatype Comparisons
| Datatype     | SQL Equivalent      | Java Equivalent         | Rust Equivalent |
|--------------+---------------------+-------------------------+-----------------|
| ~binary~       | ~BINARY~ or ~VARBINARY~ | ~byte[]~                  | ~Vec<u8>~ or ~[u8]~ |
| ~boolean~      | ~BIT~                 | ~boolean~                 | ~bool~            |
| ~decimal~      | ~DECIMAL~             | ~BigDecimal~ in ~java.math~ |                 |
| ~double~       | ~DOUBLE PRECISION~    | ~double~                  | ~f64~             |
| ~integer~      | ~INTEGER~             | ~long~                    | ~i64~             |
| ~string~       | ~CHAR~ or ~VARCHAR~     | ~String~                  | ~String~ or ~str~   |
| ~unsigned~     |                     |                         | ~u64~             |
| ~uri~          |                     |                         |                 |
| ~xsd:date~     | ~DATE~                |                         |                 |
| ~xsd:time~     | ~TIME~                |                         |                 |
| ~xsd:dateTime~ | ~DATETIME~            |                         |                 |
| ~xsd:duration~ | ~INTERVAL~            |                         |                 |

*** Logistics Example

#+BEGIN_INDENTED
The business comprises /matching/ available transportation *capacity* on one or more *routes* to /deliver/ a *customer*'s load
from /source to destination/ within some /time constraint/. A load may be one or more *standard palettes*, or one or more
*standard containers*. This results in one or more *delivery contracts*.
#+END_INDENTED

Note also that we have dropped some of the entities from
the original 

You can use Annotation Properties to attach documentation properties to your model. In the following example we have
added a /preferred label/ "Logistics" (line 6), an /alternate label/ "Shipping" (line 7), and a /description/ (line 8)
annotation to the module itself. Don't worry about the syntax of these for now, that's covered in an advanced topic
later. We have added some to the logistics example in listing [[src:initial-logistics-entities]].

#+NAME: src:initial-logistics-entities
#+CAPTION: Initial Logistics Entities
#+BEGIN_SRC sdml -n :exports code :noeval
module logistics is

  import [ dc skos uuid ]
  import [ gs1 ]

  @skos:prefLabel = "Logistics"@en
  @skos:altLabel = "Shipping"@en
  @dc:description = "A domain model for long-haul logistics."@en

  entity Location
  ; Global Location Number GLN

  enum LocationKind

  entity Consignor is
    identity gln -> GlobalLocationNumber
    lei -> {0..1} gs1:LegalEntityIdentifier
  end

  entity Consignment is
    identity ginc -> gs1:GlobalIdentificationNumberForConsignment
    consignor -> Consignor
    shipments -> {1..} Shipment
  end

  entity Shipment is

    @editorialNote =
      "need to add logistic units -- are these entities?"

    identity gsin -> gs1:GlobalShipmentIdentificationNumber
    from -> Location
    to -> Location
  end

end
#+END_SRC

It is also time to deal with the ~import~ statement (lines 3,4) that we have already seen in a number of examples. An import statement
is used to make definitions in other modules available to us in the current module. Import statements are simpler than a
lot of programming languages in that you can import /either/ a module by name /or/ individual definitions within a module.
In either case SDML requires you to use the qualified name of any imported definition. A qualified name is simply the
name of the module followed by a colon and then the name of the definition. In listing [[src:initial-logistics-entities]] we
see a single import statement with a list of module names, ~dc~ and ~skos~. These modules allow us to reference the
annotation properties ~dc:description~, ~skos:altLabel~, ~skos:definition~, and ~skos:prefLabel~.

#+BEGIN_ADVNOTE
Annotation properties are like constants in programming, they become attached to their enclosing definition and are
immutable. A property is introduced by the initial =@= character and the property name follows. This property is then
assigned a value, using the datatypes in table [[tbl:datatype-comparisons]]. Some annotations, such as those in listing
[[src:initial-logistics-entities]] above, are purely descriptive while others actually affect the semantics of the model
element they are attached to.

Strings, as you can see in listing [[src:initial-logistics-entities]] may be followed by another =@= character which
introduces a language tag that identifies the natural language used in the string constant.
#+END_ADVNOTE

** Add details with Structures and Enums
:PROPERTIES:
:CUSTOM_ID: add-structures-and-enums
:END:

Now that you have the key elements of your domain model in place, you can start to see how this becomes the core
vocabulary shared between customers, business, and technical stakeholders. However, a Store, Property, or Shipment are
really not interesting as entities without some more detail. While we did add some of the inter-entity relationships in
the previous section the only entity we added any additional members to was Booking. In the following sections we will
use two more definition types, /structures/ and /enumerations/ to add clarity and structure to the models we have developed
so far.

A structure will look very much like an entity in that it has a name and a set of members, however it does not have an
identity member. As this means we cannot include them in an entity by reference to an identifier all structures are
included /within/ any enclosing structure or entity.

An enumeration is a list of unique /variants/ that represent distinct options.

*** Retail Example

In listing [[src:initial-retail-structures]] we have added a common ~Address~ structure (line 13) that is used by the
customer, manufacturer, and store entities. This example does not introduce an enumeration directly; however, the
imported type ~AlphaTwoCountryCode~ is an enumeration (described in listing [[src:iso_3166_1]] below). Additionally, the
cardinality expression on line 25 introduces a new keyword ~ordered~ that is a constraint over the sequence that it's
members *must* maintain their order, thus the sequence acts as an array or vector. In this example we assume that the 7
elements of the sequence represent the days of the week so ordering would be important (although is the first element
Sunday or Monday?).

#+NAME: src:initial-retail-structures
#+CAPTION: Retail Structures and Enumerations
#+BEGIN_SRC sdml -n :exports code :noeval
module retail is

  import [ skos xsd ]
  import gs1
  import iso_17442
  import iso_3166_1

  entity Customer is
    identity customer_id -> unknown
    address -> Address
  end

  structure Address is
    street {1..2} -> string
    apartment {0..1} -> string
    city -> string
    state_or_district -> string
    postal_code -> string
    country -> iso_3166_1:AlphaTwoCountryCode
  end

  entity Store is
    identity location_number -> gs1:GlobalLocationNumber
    address -> Address
    open_hours -> {ordered 7} Hours
    has_pickup -> boolean
  end

  structure Hours is
    open -> xsd:time
    close -> xsd:time
  end

  entity Purchase

  entity Item is
    @skos:note = "See following advanced topic."
    identity gtin -> gs1:GlobalTradeItemNumber
    description -> string
    manufacturer -> Manufacturer
  end

  entity Manufacturer is
    identity manufacturer_id -> iso_17442:LegalEntityId
    address -> Address
  end

end
#+END_SRC

The following listing shows the definition of the enumeration ~AlphaTwoCountryCode~. The whitespace in this example should
be ignored, it is just useful to layout a grid of 26 rows of 26 columns for all the possible combination of two ASCII
upper case letters.

#+NAME: src:iso_3166_1
#+CAPTION: ISO Country Code enum
#+BEGIN_SRC sdml -n :exports code :noeval
module iso_3166_1 is

  enum AlphaTwoCountryCode of
             AD AE AF AG    AI       AL AM    AO    AQ AR AS AT AU    AW AX    AZ
    BA BB    BD BE BF BG BH BI BJ    BL BM BN BO    BQ BR BS BT    BV BW    BY BZ
    CA    CC CD    CF CG CH CI    CK CL CM CN CO       CR       CU CV CW CX CY CZ
                DE             DJ DK    DM    DO                               DZ
          EC    EE    EG EH                            ER ES ET 
                            FI FJ FK    FM    FO       FR
    ;; ...
    ;; ...
    ;; ...
    VA    VC    VE    VG    VI             VN                   VU
                   WF                                     WS
                YE                                           YT
    ZA                                  ZM                            ZW
  end

end
#+END_SRC

Given this module name, ~iso_3166_1~, we should explain the use of underscores in module names. While any name in SDML /may/
include underscores, typically as a word separator, the convention in module names is to use the underscore to note any
logical hierarchy in definitions. So we have all ISO standards start with ~iso_~ followed by the standard number ~3166~ and
then in this case the part number ~_1~.

#+BEGIN_ADVNOTE
Consider using custom datatypes to constrain basic types to avoid errors. For example, in listing [[src:initial-retail-structures]] the
identifier for an ~Item~ (line 36) is a GTIN or Global Trade Item Number. This standardized identifier has a number of specific
formats but the shortest of those is 8 characters and the longest is 13 characters. So, we create a new datatype which
/restricts/ the basic string to between 8 and 13 characters only using a regex pattern using an annotation property. This
datatype and another standard from GS1 is shown in listing [[src:gs1-datatypes]].

#+NAME: src:gs1-datatypes
#+CAPTION: GS1 Standard Datatypes
#+BEGIN_SRC sdml -n :exports code :noeval
module gs1 is

  import xsd

  datatype GlobalLocationNumber <- string is
    @xsd:pattern = "^[0-9]{13}$"
  end

  datatype GlobalTradeItemNumber <- string is
    @xsd:pattern = "(^[0-9]{8}$)|(^[0-9]{13}$)|(^[0-9]{14}$)"
  end

end
#+END_SRC

Table [[tbl:datatype-comparisons]] lists the annotation properties that can you can use to restrict existing datatypes. All
/scalar/ types have the following additional constraints; ~maxInclusive~, ~maxExclusive~, ~minInclusive~, and ~minExclusive~.

#+NAME: tbl:datatype-comparisons
#+CAPTION: Datatype Constraints
| Datatype       | Builtin Constraints                                  |
|----------------+------------------------------------------------------|
| ~binary~         | ~minLength~, ~maxLength~, and ~length~                     |
| ~boolean~        |                                                      |
| ~decimal~        | ~pattern~, ~totalDigits~, ~fractionDigits~, and /scalar/     |
| ~double~         | ~pattern~, and /scalar/                                  |
| ~integer~        | ~pattern~, and /scalar/                                  |
| ~string~         | ~pattern~, ~minLength~, ~maxLength~, ~length~, and ~langRange~ |
| ~unsigned~       | ~pattern~, and /scalar/                                  |
| ~uri~            | ~pattern~, ~minLength~, ~maxLength~, and ~length~            |
| ~xsd:date~       | ~pattern~, ~explicitTimezone~ and /scalar/                 |
| ~xsd:time~       | ~pattern~, ~explicitTimezone~ and /scalar/                 |
| ~xsd:dateTime~   | ~pattern~, ~explicitTimezone~ and /scalar/                 |
| ~xsd:duration~   | ~pattern~, ~explicitTimezone~ and /scalar/                 |
| Sequence Types | ~pattern~, ~minLength~, ~maxLength~, and ~length~            |
#+END_ADVNOTE

*** Hospitality Example

Listing [[src:initial-hospitality-structures]] adds 2 datatype definitions, 1 enum definition, and 7 structure definitions.
We have also made the previous entity ~Room~ a structure as it is dependent wholly on the valid entity ~Property~. Lines 79
and 85 introduce a new sequence constraint with the keyword ~unique~ that requires members of the sequence to be unique,
effectively defining the sequence as a set.

#+NAME: src:initial-hospitality-structures
#+CAPTION: Hospitality Structures and Enumerations
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality is

  import xsd

  entity Customer

  entity Booking is
    identity booking_code -> string
    customer -> Customer
    property -> Property
    room_style -> RoomStyle
    room_rate -> Currency
    dates -> DateRange
    number_of_adults -> integer
    number_of_children -> integer
  end

  entity Property is
    identity property_id -> unsigned
    name -> string
    styles -> {1..} RoomStyle
    rooms -> {1..} Room
  end

  entity Bill is
    identity transaction_id -> unknown
    for_stay -> Stay
    charges -> {0..} Purchase
  end

  entity Stay is
    identity id -> unknown
    booking -> {0..1} Booking
    room_number -> unsigned
    room_rate -> {0..1} Currency ;; if different from booking
    dates -> DateRange
    tax_percent -> RatePercentage
    discount_percent -> RatePercentage
  end

  datatype Currency <- decimal is
    @xsd:totalDigits = 9
    @xsd:fractionDigits = 3
  end

  datatype RatePercentage <- decimal is
    @xsd:totalDigits = 5
    @xsd:fractionDigits = 3
  end

  enum RoomFeature of
    View
    NonSmoking
    Smoking
    Accessible
    OneSingleBed
    OneDoubleBed
    OneQueenBed
    OneKingBed
    TwoSingleBeds
    TwoDoubleBeds
    TwoQueenBeds
    TwoKingBeds
    Suite
    Fridge
    Kitchen
    Balcony
  end

  structure DateRange is
    starts -> xsd:date
    ends -> xsd:date
  end

  structure Room is
    number -> unsigned
    floor -> unsigned
    style -> RoomStyle
    additional_features -> {unique 0..*} RoomFeature
    rate -> Currency
  end

  structure RoomStyle is
    name -> string
    features -> {unique 1..*} RoomFeature
  end

  structure Charge is
    item -> string
    provider -> string
    charge -> decimal
    tax_percent -> RatePercentage
    discount_percent -> RatePercentage
  end

  structure Purchase is
    stay -> Stay
    charges -> {0..} Charge
    payment -> Payment
  end

  structure Payment is
    amount -> Currency
    instrument -> PaymentInstrument
  end

  structure PaymentInstrument
end
#+END_SRC

While this module has added a lot of detail, one structure at the end, ~PaymentInstrument~ is not yet complete. Be
patient, we will come back to that in the section [[#add-unions]] later.

#+BEGIN_ADVNOTE
You can add a specific type of annotation, a constraint, to capture conditions that cannot be expressed by the model's
structure alone. For example, in listing [[src:hospitality-daterange]] we have a simple structure that contains a start date
and an end date. They are correctly typed so we know they have to be dates, but what if we were to set the start date to
be after the end date, how do we validate that? Can we?

#+NAME: src:hospitality-daterange
#+CAPTION: Hospitality Entities
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality is

  import xsd

  structure DateRange is
    assert valid_range = "range starts before it ends"

    assert formal_range is
      forall self, self.starts <= self.ends
    end

    starts -> xsd:date
    ends -> xsd:date
  end

end
#+END_SRC
#+END_ADVNOTE

*** Logistics Example

The detail added to the logistics example is extensive, but some highlights are the use of "kind" enumerations for
~Location~ (line 10), ~LogisticsUnit~ (line 48), and ~LogisticsAsset~ (line 103). We have also added a constraint to the
logistics unit structure which enforces a rule that a box may not include other units. The more astute reader will note
that this is woefully insufficient as it does not stop us defining a unit of kind palette which includes a unit of kind
rail car -- that's some big palette.

#+NAME: src:initial-logistics-structures
#+CAPTION: Logistics Structures and Enumerations
#+BEGIN_SRC sdml -n :exports code :noeval
module logistics is

  import [ dc owl rdf skos uuid ]
  import [ gs1 ]

  @skos:prefLabel = "Logistics"@en
  @skos:altLabel = "Shipping"@en
  @dc:description = "A domain model for long-haul logistics."@en

  entity Location is
    identity gln -> gs1:GlobalLocationNumber
    kind -> LocationKind
    within -> {0..1} Location
  end

  enum LocationKind of
    Office
    Warehouse
    WarehouseYard
    WarehouseDock
    RailDepot
    RailYard
    Port
    PortLoading
    Airport
    AirportTransfer
  end

  entity Consignor is
    identity gln -> gs1:GlobalLocationNumber
    lei -> {0..1} gs1:LegalEntityIdentifier
    name -> string
  end

  entity Consignment is
    identity ginc -> gs1:GlobalIdentificationNumberForConsignment
    consignor -> Consignor
    shipments -> {1..} Shipment
  end

  entity Shipment is
    identity gsin -> gs1:GlobalShipmentIdentificationNumber
    from -> Location
    to -> Location
    units -> {1..} LogisticsUnit
  end

  structure LogisticsUnit is
    assert can_include_others = "not empty(includes) implies not kind = Box"
    sscc -> gs1:SerialShippingContainerCode
    kind -> LogisticsUnitKind
    asset -> {1..} LogisticsAsset
    dimension -> Dimensions
    weight -> decimal
    hazmat_classification -> {unique 0..9} DotHazardClassification
    includes -> {0..} LogisticsUnit
  end

  enum LogisticsUnitKind of
    Box
    Pallet
    PalletStack
    Container
    RailCar
  end

  enum DotHazardClassification of
    @owl:equivalentClass = unsigned
    Explosives is
      @rdf:value = 1
    end
    Gasses is
      @rdf:value = 2
    end
    FlammableLiquids is
      @rdf:value = 3
    end
    FlammableSolids is
      @rdf:value = 4
    end
    OxodizingSubstances is
      @rdf:value = 5
    end
    ToxicSubstances is
      @rdf:value = 6
    end
    RadioactiveMaterials is
      @rdf:value = 7
    end
    CorrosiveSubstances is
      @rdf:value = 8
    end
    MiscellaneousDangerousMaterials is
      @rdf:value = 9
    end
  end

  structure Dimensions is
    height -> decimal
    width -> decimal
    depth -> decimal
  end

  structure LogisticsAsset is
    grai -> gs1:GlobalReturnableAssetIdentifier
    kind -> LogisticsAssetKind
  end

  enum LogisticsAssetKind of
    Pallet
    Container
    RailCar
  end

end
#+END_SRC

You will probably be thinking that all this detail is making the module quite large and possibly cumbersome. In the
following section ([[#add-events]]) we will discuss approaches to organizing modules to allow not only ease of navigation
but also parallel editing.

#+BEGIN_ADVNOTE
The enumeration ~DotHazardClassification~ in listing [[src:initial-logistics-structures]] above probably looks
intimidating compared to the previous examples, and that's OK. This enumeration represents the U.S. Department of
Transportation's Federal Motor Carrier Safety Administration's  "Nine Classes of Hazardous Material" classification. As
such the values one through nine are defined by government and so we want to be able to associate those values with the
variants of the enum.

We use two key annotation properties that affect the semantics of the enum.

- ~rdf:value~ :: this denotes the relationship between the variant and a specific value. It is not important that the
  values are numbers, only that they are of the same type and unique.
- ~owl:equivalentClass~ :: this denotes that the enumeration may be /considered equivalent/ to the some type. It is
  important that all values attached to variants are valid for the type attached to the enum.

Also, the cardinality expression on member ~hazmat_classification~ is ~{unique 1..9}~, to denote that while a unit may
contain a combination of coded materials each code appears only once.
#+END_ADVNOTE

** Describe Events emitted by Entities
:PROPERTIES:
:CUSTOM_ID: add-events
:END:

SDML does not have a language for describing behavior, so no sequence, activity, state machine, or other diagrams. Given
that the domain model should describe the /what/ of a domain, not the /how/ it is too tempting to start to describe the
behavior inside the domain, it's operating rules. Additionally, when describing a domain model it is often the case that
the language used by stakeholders to describe any functional aspect of the model tends to be asynchronous and loosely
coupled. To support this SDML provides the ~event~ definition, a way to describe events emitted by entities on state
changes or other internal rules, but importantly these are part of the natural description/vocabulary of the domain.

An event looks very much like a structure, but is has a ~source~ keyword followed by the name of the entity which emits
this event. In fact the similarity between an event and a structure is not accidental as it's possible to see an event
definition as some additional syntax for a structure which, and this is the important part, contains a reference to an
instance of the entity type. In listing [[src:example-event-desugared]] we have a simple entity (line 5) and a simple event
(line 10) emitted by the entity. If we were to create an equivalent structure it might look like that defined on line
13, which in turn is equivalent to the second structure on line 18.  

#+NAME: src:example-event-desugared
#+CAPTION: Event De-Sugaring
#+BEGIN_SRC sdml -n :exports code :noeval
module example is

  import uuid

  entity Example is
    identity id -> uuid:Uuid
    some_other_thing -> integer
  end

  event ExampleCreated source Example

  ;; the above event is "equivalent" to the structure below
  structure ExampleCreatedStructure is
    source_entity -> Example
  end

  ;; the above is also "equivalent" to the structure below
  structure ExampleCreatedStructure2 is
    source_entity_id -> uuid:Uuid
  end

end
#+END_SRC

One specific different between a structure definition and an event definition is that the former without an explicit
body (between ~is~ and ~end~) is incomplete, an event does not need a body as it does already have a single member, the
source entity. In many cases events need only be a distinct type with a reference to the particular entity and no other
information.

*** Retail Example



#+NAME: src:initial-retail-events-customer
#+CAPTION: Events for Retail Customers
#+BEGIN_SRC sdml -n :exports code :noeval
module retail_customers is

  entity Customer

  entity Purchase

  structure ItemQuantity is
    item -> Item
    quantity -> integer
  end

  event InventoryAdjustment source Purchase is
    adjustments -> {1..} ItemQuantity
  end

end
#+END_SRC

#+NAME: src:initial-retail-events-store
#+CAPTION: Events for Retail Stores
#+BEGIN_SRC sdml -n :exports code :noeval
module retail is

  entity Store

  event StoreNowOpen source Store is
    at -> xsd:dateTime
  end
  event StoreNowClosed source Store is
    at -> xsd:dateTime
  end

end
#+END_SRC

#+NAME: src:initial-retail-events-item
#+CAPTION: Events for Retail Items
#+BEGIN_SRC sdml -n :exports code :noeval
module retail is

  entity Item

  entity Manufacturer

end
#+END_SRC

*** Hospitality Example

#+NAME: src:initial-hospitality-events-customer
#+CAPTION: Events for Hospitality Customers
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality_customers is

  entity Customer

  entity Booking

  enum BookingChange of
    RoomStyle
    Dates
    Occupancy
  end

  event BookingCreated source Booking
  event BookingUpdated source Booking is
    what_changed -> BookingChange
  end
  event BookingCanceled source Booking is
    reason -> string
  end

end
#+END_SRC

#+NAME: src:initial-hospitality-events-property
#+CAPTION: Events for Hospitality Properties
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality_properties is

  entity Property

  entity Stay

  event CheckedIn source Stay
  event CheckedOut source Stay
  event RoomCharged source Stay is
    charge -> Charge
  end

  entity Bill

  event BillReady source Bill
  event PaymentMade source Bill is
    payment -> Payment
  end
  event Settled source Bill

end
#+END_SRC

*** Logistics Example

#+NAME: src:initial-logistics-events
#+CAPTION: Logistics Events
#+BEGIN_SRC sdml -n :exports code :noeval
module logistics is

  import [ dc skos uuid ]
  import [ gs1 ]

  @skos:prefLabel = "Logistics"@en
  @skos:altLabel = "Shipping"@en
  @dc:description = "A domain model for long-haul logistics."@en

  entity Consignor

  ;; based uopn ANSI X.12 204
  event CarrierLoadTender source Consignor

  entity Carrier

  ;; based uopn ANSI X.12 990
  event CarrierLoadTenderResponse source Carrier

  entity Consignment

  ;; based uopn ANSI X.12 211
  event BillOfLading source Consignment
  ;; based uopn ANSI   X.12 210
  event FreightDetailsAndInvoice source Consignment

  entity Shipment

  ;; based uopn ANSI X.12 856
  event AdvanceShippingNotice source Shipment
  ;; based uopn ANSI X.12 214
  event TransportStatusNotification source Shipment
  event TransferRequest source Shipment
  event TransferConfirmation source Shipment

  enum TransferKind of
    Pickup
    Dropoff
  end

end
#+END_SRC

** Describe "This or That" with Unions
:PROPERTIES:
:CUSTOM_ID: add-unions
:END:

So far we have ween entities, structures, events, and enumerations.

*** Hospitality Example

#+NAME: src:initial-hospitality-structure
#+CAPTION: Using a Structure for PaymentInstrument
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality_properties is

  import pii

  structure PaymentInstrument is
    assert only_one =
      "one, and only one, member may be present"
    cash -> {0..1} Currency
    credit_balance -> {0..1} Currency
    points -> {0..1} unsigned
    card -> {0..1} pii:CardToken
  end

end
#+END_SRC

#+NAME: src:initial-hospitality-union
#+CAPTION: Using a Union for PaymentInstrument
#+BEGIN_SRC sdml -n :exports code :noeval
module hospitality_properties is

  import pii

  union PaymentInstrument of
    Currency as Cash
    Currency as CreditBalance
    unsigned as Points
    pii:CardToken as Card
  end

end
#+END_SRC

*** Logistics Example

#+NAME: src:gtin-union
#+CAPTION: Using a Union for GTIN
#+BEGIN_SRC sdml -n :exports code :noeval
module gs1 is

  import [ xsd ]

  datatype UniversalProductCode <- string
  datatype EuropeanArticleNumber <- string
  datatype InternationalStandardBookNumber <- string
  datatype InternationalStandardMusicNumber <- string
  datatype InternationalStandardSerialNumber <- string

  union GlobalTradeIdentificationNumber of
    @skos:prefLabel = "Global Trade Identification Number"@en
    @skos:altLabel = "GTIN"@en
    UniversalProductCode
    EuropeanArticleNumber
    InternationalStandardBookNumber
    InternationalStandardMusicNumber
    InternationalStandardSerialNumber
  end

end
#+END_SRC

* How do I use it?
:PROPERTIES:
:CUSTOM_ID: how-to-use
:END:

DDD

** Editing SDML Source
** Drawing Diagrams

#+NAME: src:initial-hospitality-drawings
#+BEGIN_SRC sdml :exports none :noeval
module hospitality is

  import xsd
  import pii

  entity Customer

  event BookingCreated source Booking
  event BookingUpdated source Booking
  event BookingCanceled source Booking

  entity Booking is
    identity booking_code -> string
    customer -> Customer
    property -> Property
    room_style -> RoomStyle
    room_rate -> Currency
    dates -> DateRange
    number_of_adults -> Occupancy
    number_of_children -> Occupancy
  end

  entity Property is
    identity property_id -> unsigned
    name -> string
    styles -> {1..} RoomStyle
    rooms -> {1..} Room
  end

  entity Bill is
    identity transaction_id -> unknown
    for_stay -> Stay
    charges -> {0..} Purchase
  end

  event BillReady source Bill
  event PaymentMade source Bill
  event Settled source Bill

  entity Stay is
    identity id -> unknown
    booking -> {0..1} Booking
    room_number -> unsigned
    room_rate -> {0..1} Currency ;; if different from booking
    dates -> DateRange
    tax_percent -> RatePercentage
    discount_percent -> RatePercentage
  end

  event CheckedIn source Stay
  event CheckedOut source Stay
  event RoomCharged source Stay

  datatype Currency <- decimal is
    @xsd:totalDigits = 9
    @xsd:fractionDigits = 3
  end

  datatype RatePercentage <- decimal is
    @xsd:totalDigits = 5
    @xsd:fractionDigits = 3
  end

  datatype Occupancy <- unsigned is
    @xsd:maxInclusive = 4
    @xsd:minInclusive = 1
  end

  enum RoomFeature of
    View
    NonSmoking
    Smoking
    Accessible
    OneSingleBed
    OneDoubleBed
    OneQueenBed
    OneKingBed
    TwoSingleBeds
    TwoDoubleBeds
    TwoQueenBeds
    TwoKingBeds
    Suite
    Fridge
    Kitchen
    Balcony
  end

  structure DateRange is
    starts -> xsd:date
    ends -> xsd:date
  end

  structure Room is
    number -> unsigned
    floor -> unsigned
    style -> RoomStyle
    additional_features -> {unique 0..*} RoomFeature
    rate -> Currency
  end

  structure RoomStyle is
    name -> string
    features -> {unique 1..*} RoomFeature
  end

  structure Charge is
    item -> string
    provider -> string
    charge -> Currency
    tax_percent -> RatePercentage
    discount_percent -> RatePercentage
  end

  structure Purchase is
    stay -> Stay
    charges -> {0..} Charge
    payment -> Payment
  end

  structure Payment is
    amount -> Currency
    instrument -> PaymentInstrument
  end

  union PaymentInstrument of
    Currency as Cash
    Currency as CreditBalance
    unsigned as Points
    pii:CardToken as Card
  end

end
#+END_SRC

#+NAME: src:initial-hospitality-drawing-concepts
#+BEGIN_SRC sdml :cmdline draw --diagram concepts --output-format svg :file ./images/primer-hospitality-concepts.svg :exports results :noweb yes
<<src:initial-hospitality-drawings>>
#+END_SRC

#+NAME: fig:initial-hospitality-drawing-concepts
#+CAPTION: Hospitality Concepts (Entities)
#+RESULTS: src:initial-hospitality-drawing-concepts
[[file:./images/primer-hospitality-concepts.svg]]

#+NAME: src:initial-hospitality-drawing-uml
#+BEGIN_SRC sdml :cmdline draw --diagram uml-class --output-format svg :file ./images/primer-hospitality-uml.svg :exports results :noweb yes
<<src:initial-hospitality-drawings>>
#+END_SRC

#+NAME: fig:initial-hospitality-drawing-uml
#+CAPTION: Hospitality UML
#+RESULTS: src:initial-hospitality-drawing-uml
[[file:./images/primer-hospitality-uml.svg]]

** Document Modules

* What do I do next?
:PROPERTIES:
:CUSTOM_ID: what-next
:END:

TBD

** For Authors

** For Tool Builders

** More Reading

- [[https://sdml.io#intro-what-is-domain-modeling][What is Domain Modeling?]] in the SDML documentation.
- [[https://www.thoughtworks.com/en-us/insights/blog/agile-project-management/domain-modeling-what-you-need-to-know-before-coding][Domain Modeling: What you need to know before coding]], Norberto RodrÃ­guez (Norbs). Thoughtworks.
- [[https://olegchursin.medium.com/a-brief-introduction-to-domain-modeling-862a30b38353][A Brief Introduction to Domain Modeling]], Oleg Chursin.
- [[https://simplea.com/Articles/domain-model][What is a Domain Model?]], [A].
- [[https://en.wikipedia.org/wiki/Domain_model][Domain Model]], Wikipedia.

* A Brief Glossary
:PROPERTIES:
:CUSTOM_ID: glossary
:END:

- Annotation :: A /property/ or /constraint/ attached to a definition that may document, classify, or constrain the
  definition in ways the SDML syntax cannot. For example, attaching a descriptive property, a prescriptive definition,
  or categorization labels.
- Constraint :: A mechanism to describe correctness, or well-formedness, rules for a particular model and specifically
  those rules that may be hard or impossible to capture in the SDML syntax itself.
- Datatype :: An unstructured type that describes the atomic values (strings, numbers, etc.) in a model. Making a
  datatype more specific such as saying a string has 4-10 characters only, or a quantity is 1-100 only, documents more
  information than string/number alone.
- Definition :: In SDML all elements in a model such as modules, entities, structures, fields in a structure, or variants
  of an enumeration, are definitions. Definitions all have an identity which is unique within it's parent /namespace/.
- Domain ::
- Domain Model ::
- Domain-Driven Development ::
- Entity ::
- Enumeration ::
- Features ::
- Formal Constraint :: 
- Informal Constraint :: 
- Member :: A member is a field within a /product type/, consisting of a name and target type. A member may alternatively
  be a reference to a property /role/.
- Model ::
- Module :: 
- Namespace ::
- Ordering (Sequence) :: A constraint that denotes whether a /sequence/ is ordered or unordered.
- Product Type :: A product type is one of /entity/, /event/, or /structure/.
- Property (Annotation) :: 
- Property (Member) ::
- Role :: 
- Sequence :: 
- Structure ::
- Sum Type :: A sum type is one of /enumeration/, /property/, or /union/.
- Type Variant :: 
- UML :: 
- Union ::
- Uniqueness (Sequence) :: A constraint that denotes whether a /sequence/ contains only unique elements or is non-unique.
- Value Variant :: 
- Variant :: A unique 

#  LocalWords:  lifecycle iteratively UML SDML RDF genericity datatypes namespace formedness
